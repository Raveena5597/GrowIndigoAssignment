{"ast":null,"code":"// This is a port of Google Android `libphonenumber`'s\n// `phonenumberutil.js` of December 31th, 2018.\n//\n// https://github.com/googlei18n/libphonenumber/commits/master/javascript/i18n/phonenumbers/phonenumberutil.js\nimport { VALID_DIGITS, PLUS_CHARS, MIN_LENGTH_FOR_NSN, MAX_LENGTH_FOR_NSN, MAX_LENGTH_COUNTRY_CODE } from './constants';\nimport { matchesEntirely } from './util';\nimport ParseError from './ParseError';\nimport Metadata from './metadata';\nimport isViablePhoneNumber from './isViablePhoneNumber';\nimport { extractExtension } from './extension';\nimport parseIncompletePhoneNumber from './parseIncompletePhoneNumber';\nimport getCountryCallingCode from './getCountryCallingCode';\nimport getNumberType from './getNumberType_';\nimport checkNumberLength from './checkNumberLength';\nimport { isPossibleNumber } from './isPossibleNumber_';\nimport { stripIDDPrefix } from './IDD';\nimport { parseRFC3966 } from './RFC3966';\nimport PhoneNumber from './PhoneNumber'; // We don't allow input strings for parsing to be longer than 250 chars.\n// This prevents malicious input from consuming CPU.\n\nvar MAX_INPUT_STRING_LENGTH = 250; // This consists of the plus symbol, digits, and arabic-indic digits.\n\nvar PHONE_NUMBER_START_PATTERN = new RegExp('[' + PLUS_CHARS + VALID_DIGITS + ']'); // Regular expression of trailing characters that we want to remove.\n// A trailing `#` is sometimes used when writing phone numbers with extensions in US.\n// Example: \"+1 (645) 123 1234-910#\" number has extension \"910\".\n\nvar AFTER_PHONE_NUMBER_END_PATTERN = new RegExp('[^' + VALID_DIGITS + '#' + ']+$');\nvar USE_NON_GEOGRAPHIC_COUNTRY_CODE = false; // `options`:\n//  {\n//    country:\n//    {\n//      restrict - (a two-letter country code)\n//                 the phone number must be in this country\n//\n//      default - (a two-letter country code)\n//                default country to use for phone number parsing and validation\n//                (if no country code could be derived from the phone number)\n//    }\n//  }\n//\n// Returns `{ country, number }`\n//\n// Example use cases:\n//\n// ```js\n// parse('8 (800) 555-35-35', 'RU')\n// parse('8 (800) 555-35-35', 'RU', metadata)\n// parse('8 (800) 555-35-35', { country: { default: 'RU' } })\n// parse('8 (800) 555-35-35', { country: { default: 'RU' } }, metadata)\n// parse('+7 800 555 35 35')\n// parse('+7 800 555 35 35', metadata)\n// ```\n//\n\nexport default function parse(text, options, metadata) {\n  // If assigning the `{}` default value is moved to the arguments above,\n  // code coverage would decrease for some weird reason.\n  options = options || {};\n  metadata = new Metadata(metadata); // Validate `defaultCountry`.\n\n  if (options.defaultCountry && !metadata.hasCountry(options.defaultCountry)) {\n    if (options.v2) {\n      throw new ParseError('INVALID_COUNTRY');\n    }\n\n    throw new Error(\"Unknown country: \".concat(options.defaultCountry));\n  } // Parse the phone number.\n\n\n  var _parseInput = parseInput(text, options.v2),\n      formattedPhoneNumber = _parseInput.number,\n      ext = _parseInput.ext; // If the phone number is not viable then return nothing.\n\n\n  if (!formattedPhoneNumber) {\n    if (options.v2) {\n      throw new ParseError('NOT_A_NUMBER');\n    }\n\n    return {};\n  }\n\n  var _parsePhoneNumber = parsePhoneNumber(formattedPhoneNumber, options.defaultCountry, options.defaultCallingCode, metadata),\n      country = _parsePhoneNumber.country,\n      nationalNumber = _parsePhoneNumber.nationalNumber,\n      countryCallingCode = _parsePhoneNumber.countryCallingCode,\n      carrierCode = _parsePhoneNumber.carrierCode;\n\n  if (!metadata.hasSelectedNumberingPlan()) {\n    if (options.v2) {\n      throw new ParseError('INVALID_COUNTRY');\n    }\n\n    return {};\n  } // Validate national (significant) number length.\n\n\n  if (!nationalNumber || nationalNumber.length < MIN_LENGTH_FOR_NSN) {\n    // Won't throw here because the regexp already demands length > 1.\n\n    /* istanbul ignore if */\n    if (options.v2) {\n      throw new ParseError('TOO_SHORT');\n    } // Google's demo just throws an error in this case.\n\n\n    return {};\n  } // Validate national (significant) number length.\n  //\n  // A sidenote:\n  //\n  // They say that sometimes national (significant) numbers\n  // can be longer than `MAX_LENGTH_FOR_NSN` (e.g. in Germany).\n  // https://github.com/googlei18n/libphonenumber/blob/7e1748645552da39c4e1ba731e47969d97bdb539/resources/phonenumber.proto#L36\n  // Such numbers will just be discarded.\n  //\n\n\n  if (nationalNumber.length > MAX_LENGTH_FOR_NSN) {\n    if (options.v2) {\n      throw new ParseError('TOO_LONG');\n    } // Google's demo just throws an error in this case.\n\n\n    return {};\n  }\n\n  if (options.v2) {\n    var phoneNumber = new PhoneNumber(countryCallingCode, nationalNumber, metadata.metadata);\n\n    if (country) {\n      phoneNumber.country = country;\n    }\n\n    if (carrierCode) {\n      phoneNumber.carrierCode = carrierCode;\n    }\n\n    if (ext) {\n      phoneNumber.ext = ext;\n    }\n\n    return phoneNumber;\n  } // Check if national phone number pattern matches the number.\n  // National number pattern is different for each country,\n  // even for those ones which are part of the \"NANPA\" group.\n\n\n  var valid = (options.extended ? metadata.hasSelectedNumberingPlan() : country) ? matchesEntirely(nationalNumber, metadata.nationalNumberPattern()) : false;\n\n  if (!options.extended) {\n    return valid ? result(country, nationalNumber, ext) : {};\n  } // isInternational: countryCallingCode !== undefined\n\n\n  return {\n    country: country,\n    countryCallingCode: countryCallingCode,\n    carrierCode: carrierCode,\n    valid: valid,\n    possible: valid ? true : options.extended === true && metadata.possibleLengths() && isPossibleNumber(nationalNumber, metadata) ? true : false,\n    phone: nationalNumber,\n    ext: ext\n  };\n}\n/**\r\n * Extracts a formatted phone number from text.\r\n * Doesn't guarantee that the extracted phone number\r\n * is a valid phone number (for example, doesn't validate its length).\r\n * @param  {string} text\r\n * @param  {boolean} throwOnError — By default, it won't throw if the text is too long.\r\n * @return {string}\r\n * @example\r\n * // Returns \"(213) 373-4253\".\r\n * extractFormattedPhoneNumber(\"Call (213) 373-4253 for assistance.\")\r\n */\n\nexport function extractFormattedPhoneNumber(text, throwOnError) {\n  if (!text) {\n    return;\n  }\n\n  if (text.length > MAX_INPUT_STRING_LENGTH) {\n    if (throwOnError) {\n      throw new ParseError('TOO_LONG');\n    }\n\n    return;\n  } // Attempt to extract a possible number from the string passed in\n\n\n  var startsAt = text.search(PHONE_NUMBER_START_PATTERN);\n\n  if (startsAt < 0) {\n    return;\n  }\n\n  return text // Trim everything to the left of the phone number\n  .slice(startsAt) // Remove trailing non-numerical characters\n  .replace(AFTER_PHONE_NUMBER_END_PATTERN, '');\n}\n/**\r\n * Strips any national prefix (such as 0, 1) present in a\r\n * (possibly incomplete) number provided.\r\n * \"Carrier codes\" are only used  in Colombia and Brazil,\r\n * and only when dialing within those countries from a mobile phone to a fixed line number.\r\n * Sometimes it won't actually strip national prefix\r\n * and will instead prepend some digits to the `number`:\r\n * for example, when number `2345678` is passed with `VI` country selected,\r\n * it will return `{ number: \"3402345678\" }`, because `340` area code is prepended.\r\n * @param {string} number — National number digits.\r\n * @param {object} metadata — Metadata with country selected.\r\n * @return {object} `{ nationalNumber: string, nationalPrefix: string? carrierCode: string? }`.\r\n */\n\nexport function extractNationalNumberFromPossiblyIncompleteNumber(number, metadata) {\n  if (number && metadata.numberingPlan.nationalPrefixForParsing()) {\n    // See METADATA.md for the description of\n    // `national_prefix_for_parsing` and `national_prefix_transform_rule`.\n    // Attempt to parse the first digits as a national prefix.\n    var prefixPattern = new RegExp('^(?:' + metadata.numberingPlan.nationalPrefixForParsing() + ')');\n    var prefixMatch = prefixPattern.exec(number);\n\n    if (prefixMatch) {\n      var nationalNumber;\n      var carrierCode; // https://gitlab.com/catamphetamine/libphonenumber-js/-/blob/master/METADATA.md#national_prefix_for_parsing--national_prefix_transform_rule\n      // If a `national_prefix_for_parsing` has any \"capturing groups\"\n      // then it means that the national (significant) number is equal to\n      // those \"capturing groups\" transformed via `national_prefix_transform_rule`,\n      // and nothing could be said about the actual national prefix:\n      // what is it and was it even there.\n      // If a `national_prefix_for_parsing` doesn't have any \"capturing groups\",\n      // then everything it matches is a national prefix.\n      // To determine whether `national_prefix_for_parsing` matched any\n      // \"capturing groups\", the value of the result of calling `.exec()`\n      // is looked at, and if it has non-undefined values where there're\n      // \"capturing groups\" in the regular expression, then it means\n      // that \"capturing groups\" have been matched.\n      // It's not possible to tell whether there'll be any \"capturing gropus\"\n      // before the matching process, because a `national_prefix_for_parsing`\n      // could exhibit both behaviors.\n\n      var capturedGroupsCount = prefixMatch.length - 1;\n      var hasCapturedGroups = capturedGroupsCount > 0 && prefixMatch[capturedGroupsCount];\n\n      if (metadata.nationalPrefixTransformRule() && hasCapturedGroups) {\n        nationalNumber = number.replace(prefixPattern, metadata.nationalPrefixTransformRule()); // If there's more than one captured group,\n        // then carrier code is the second one.\n\n        if (capturedGroupsCount > 1) {\n          carrierCode = prefixMatch[1];\n        }\n      } // If there're no \"capturing groups\",\n      // or if there're \"capturing groups\" but no\n      // `national_prefix_transform_rule`,\n      // then just strip the national prefix from the number,\n      // and possibly a carrier code.\n      // Seems like there could be more.\n      else {\n          // `prefixBeforeNationalNumber` is the whole substring matched by\n          // the `national_prefix_for_parsing` regular expression.\n          // There seem to be no guarantees that it's just a national prefix.\n          // For example, if there's a carrier code, it's gonna be a\n          // part of `prefixBeforeNationalNumber` too.\n          var prefixBeforeNationalNumber = prefixMatch[0];\n          nationalNumber = number.slice(prefixBeforeNationalNumber.length); // If there's at least one captured group,\n          // then carrier code is the first one.\n\n          if (hasCapturedGroups) {\n            carrierCode = prefixMatch[1];\n          }\n        } // Tries to guess whether a national prefix was present in the input.\n      // This is not something copy-pasted from Google's library:\n      // they don't seem to have an equivalent for that.\n      // So this isn't an \"officially approved\" way of doing something like that.\n      // But since there seems no other existing method, this library uses it.\n\n\n      var nationalPrefix;\n\n      if (hasCapturedGroups) {\n        var possiblePositionOfTheFirstCapturedGroup = number.indexOf(prefixMatch[1]);\n        var possibleNationalPrefix = number.slice(0, possiblePositionOfTheFirstCapturedGroup); // Example: an Argentinian (AR) phone number `0111523456789`.\n        // `prefixMatch[0]` is `01115`, and `$1` is `11`,\n        // and the rest of the phone number is `23456789`.\n        // The national number is transformed via `9$1` to `91123456789`.\n        // National prefix `0` is detected being present at the start.\n        // if (possibleNationalPrefix.indexOf(metadata.numberingPlan.nationalPrefix()) === 0) {\n\n        if (possibleNationalPrefix === metadata.numberingPlan.nationalPrefix()) {\n          nationalPrefix = metadata.numberingPlan.nationalPrefix();\n        }\n      } else {\n        nationalPrefix = prefixMatch[0];\n      }\n\n      return {\n        nationalNumber: nationalNumber,\n        nationalPrefix: nationalPrefix,\n        carrierCode: carrierCode\n      };\n    }\n  }\n\n  return {\n    nationalNumber: number\n  };\n} // In some countries, the same digit could be a national prefix\n// or a leading digit of a valid phone number.\n// For example, in Russia, national prefix is `8`,\n// and also `800 555 35 35` is a valid number\n// in which `8` is not a national prefix, but the first digit\n// of a national (significant) number.\n// Same's with Belarus:\n// `82004910060` is a valid national (significant) number,\n// but `2004910060` is not.\n// To support such cases (to prevent the code from always stripping\n// national prefix), a condition is imposed: a national prefix\n// is not extracted when the original number is \"viable\" and the\n// resultant number is not, a \"viable\" national number being the one\n// that matches `national_number_pattern`.\n\nfunction shouldExtractNationalPrefix(number, nationalSignificantNumber, metadata) {\n  // The equivalent in Google's code is:\n  // https://github.com/google/libphonenumber/blob/e326fa1fc4283bb05eb35cb3c15c18f98a31af33/java/libphonenumber/src/com/google/i18n/phonenumbers/PhoneNumberUtil.java#L2969-L3004\n  if (matchesEntirely(number, metadata.nationalNumberPattern()) && !matchesEntirely(nationalSignificantNumber, metadata.nationalNumberPattern())) {\n    return false;\n  } // Just \"possible\" number check would be more relaxed, so it's not used.\n  // if (isPossibleNumber(number, metadata) &&\n  // \t!isPossibleNumber(numberWithNationalPrefixExtracted, metadata)) {\n  // \treturn false\n  // }\n\n\n  return true;\n}\n\nexport function findCountryCode(callingCode, nationalPhoneNumber, metadata) {\n  /* istanbul ignore if */\n  if (USE_NON_GEOGRAPHIC_COUNTRY_CODE) {\n    if (metadata.isNonGeographicCallingCode(callingCode)) {\n      return '001';\n    }\n  } // Is always non-empty, because `callingCode` is always valid\n\n\n  var possibleCountries = metadata.getCountryCodesForCallingCode(callingCode);\n\n  if (!possibleCountries) {\n    return;\n  } // If there's just one country corresponding to the country code,\n  // then just return it, without further phone number digits validation.\n\n\n  if (possibleCountries.length === 1) {\n    return possibleCountries[0];\n  }\n\n  return _findCountryCode(possibleCountries, nationalPhoneNumber, metadata.metadata);\n} // Changes `metadata` `country`.\n\nfunction _findCountryCode(possibleCountries, nationalPhoneNumber, metadata) {\n  metadata = new Metadata(metadata);\n\n  for (var _iterator = possibleCountries, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n    var _ref;\n\n    if (_isArray) {\n      if (_i >= _iterator.length) break;\n      _ref = _iterator[_i++];\n    } else {\n      _i = _iterator.next();\n      if (_i.done) break;\n      _ref = _i.value;\n    }\n\n    var country = _ref;\n    metadata.country(country); // Leading digits check would be the simplest one\n\n    if (metadata.leadingDigits()) {\n      if (nationalPhoneNumber && nationalPhoneNumber.search(metadata.leadingDigits()) === 0) {\n        return country;\n      }\n    } // Else perform full validation with all of those\n    // fixed-line/mobile/etc regular expressions.\n    else if (getNumberType({\n        phone: nationalPhoneNumber,\n        country: country\n      }, undefined, metadata.metadata)) {\n        return country;\n      }\n  }\n}\n/**\r\n * @param  {string} text - Input.\r\n * @return {object} `{ ?number, ?ext }`.\r\n */\n\n\nfunction parseInput(text, v2) {\n  // Parse RFC 3966 phone number URI.\n  if (text && text.indexOf('tel:') === 0) {\n    return parseRFC3966(text);\n  }\n\n  var number = extractFormattedPhoneNumber(text, v2); // If the phone number is not viable, then abort.\n\n  if (!number || !isViablePhoneNumber(number)) {\n    return {};\n  } // Attempt to parse extension first, since it doesn't require region-specific\n  // data and we want to have the non-normalised number here.\n\n\n  var withExtensionStripped = extractExtension(number);\n\n  if (withExtensionStripped.ext) {\n    return withExtensionStripped;\n  }\n\n  return {\n    number: number\n  };\n}\n/**\r\n * Creates `parse()` result object.\r\n */\n\n\nfunction result(country, nationalNumber, ext) {\n  var result = {\n    country: country,\n    phone: nationalNumber\n  };\n\n  if (ext) {\n    result.ext = ext;\n  }\n\n  return result;\n}\n/**\r\n * Parses a viable phone number.\r\n * @param {string} formattedPhoneNumber — Example: \"(213) 373-4253\".\r\n * @param {string} [defaultCountry]\r\n * @param {string} [defaultCallingCode]\r\n * @param {Metadata} metadata\r\n * @return {object} Returns `{ country: string?, countryCallingCode: string?, nationalNumber: string? }`.\r\n */\n\n\nfunction parsePhoneNumber(formattedPhoneNumber, defaultCountry, defaultCallingCode, metadata) {\n  // Extract calling code from phone number.\n  var _extractCountryCallin = extractCountryCallingCode(parseIncompletePhoneNumber(formattedPhoneNumber), defaultCountry, defaultCallingCode, metadata.metadata),\n      countryCallingCode = _extractCountryCallin.countryCallingCode,\n      number = _extractCountryCallin.number; // Choose a country by `countryCallingCode`.\n\n\n  var country;\n\n  if (countryCallingCode) {\n    metadata.selectNumberingPlan(countryCallingCode);\n  } // If `formattedPhoneNumber` is in \"national\" format\n  // then `number` is defined and `countryCallingCode` isn't.\n  else if (number && (defaultCountry || defaultCallingCode)) {\n      metadata.selectNumberingPlan(defaultCountry, defaultCallingCode);\n\n      if (defaultCountry) {\n        country = defaultCountry;\n      } else {\n        /* istanbul ignore if */\n        if (USE_NON_GEOGRAPHIC_COUNTRY_CODE) {\n          if (metadata.isNonGeographicCallingCode(defaultCallingCode)) {\n            country = '001';\n          }\n        }\n      }\n\n      countryCallingCode = defaultCallingCode || getCountryCallingCode(defaultCountry, metadata.metadata);\n    } else return {};\n\n  if (!number) {\n    return {\n      countryCallingCode: countryCallingCode\n    };\n  }\n\n  var _extractNationalNumbe = extractNationalNumber(parseIncompletePhoneNumber(number), metadata),\n      nationalNumber = _extractNationalNumbe.nationalNumber,\n      carrierCode = _extractNationalNumbe.carrierCode; // Sometimes there are several countries\n  // corresponding to the same country phone code\n  // (e.g. NANPA countries all having `1` country phone code).\n  // Therefore, to reliably determine the exact country,\n  // national (significant) number should have been parsed first.\n  //\n  // When `metadata.json` is generated, all \"ambiguous\" country phone codes\n  // get their countries populated with the full set of\n  // \"phone number type\" regular expressions.\n  //\n\n\n  var exactCountry = findCountryCode(countryCallingCode, nationalNumber, metadata);\n\n  if (exactCountry) {\n    country = exactCountry;\n    /* istanbul ignore if */\n\n    if (exactCountry === '001') {// Can't happen with `USE_NON_GEOGRAPHIC_COUNTRY_CODE` being `false`.\n      // If `USE_NON_GEOGRAPHIC_COUNTRY_CODE` is set to `true` for some reason,\n      // then remove the \"istanbul ignore if\".\n    } else {\n      metadata.country(country);\n    }\n  }\n\n  return {\n    country: country,\n    countryCallingCode: countryCallingCode,\n    nationalNumber: nationalNumber,\n    carrierCode: carrierCode\n  };\n}\n/**\r\n * Strips national prefix and carrier code from a complete phone number.\r\n * The difference from the non-\"FromCompleteNumber\" function is that\r\n * it won't extract national prefix if the resultant number is too short\r\n * to be a complete number for the selected phone numbering plan.\r\n * @param  {string} number — Complete phone number digits.\r\n * @param  {Metadata} metadata — Metadata with a phone numbering plan selected.\r\n * @return {object} `{ nationalNumber: string, carrierCode: string? }`.\r\n */\n\n\nexport function extractNationalNumber(number, metadata) {\n  // Parsing national prefixes and carrier codes\n  // is only required for local phone numbers\n  // but some people don't understand that\n  // and sometimes write international phone numbers\n  // with national prefixes (or maybe even carrier codes).\n  // http://ucken.blogspot.ru/2016/03/trunk-prefixes-in-skype4b.html\n  // Google's original library forgives such mistakes\n  // and so does this library, because it has been requested:\n  // https://github.com/catamphetamine/libphonenumber-js/issues/127\n  var _extractNationalNumbe2 = extractNationalNumberFromPossiblyIncompleteNumber(number, metadata),\n      nationalNumber = _extractNationalNumbe2.nationalNumber,\n      carrierCode = _extractNationalNumbe2.carrierCode;\n\n  if (!shouldExtractNationalPrefix(number, nationalNumber, metadata)) {\n    // Don't strip the national prefix.\n    return {\n      nationalNumber: number\n    };\n  } // If a national prefix has been extracted, check to see\n  // if the resultant number isn't too short.\n  // Same code in Google's `libphonenumber`:\n  // https://github.com/google/libphonenumber/blob/e326fa1fc4283bb05eb35cb3c15c18f98a31af33/java/libphonenumber/src/com/google/i18n/phonenumbers/PhoneNumberUtil.java#L3291-L3302\n  // For some reason, they do this check right after the `national_number_pattern` check\n  // this library does in `shouldExtractNationalPrefix()` function.\n  // Why is there a second \"resultant\" number validity check?\n  // They don't provide an explanation.\n  // This library just copies the behavior.\n\n\n  if (number.length !== nationalNumber.length + (carrierCode ? carrierCode.length : 0)) {\n    // If not using legacy generated metadata (before version `1.0.18`)\n    // then it has \"possible lengths\", so use those to validate the number length.\n    if (metadata.possibleLengths()) {\n      // \"We require that the NSN remaining after stripping the national prefix and\n      // carrier code be long enough to be a possible length for the region.\n      // Otherwise, we don't do the stripping, since the original number could be\n      // a valid short number.\"\n      // https://github.com/google/libphonenumber/blob/876268eb1ad6cdc1b7b5bef17fc5e43052702d57/java/libphonenumber/src/com/google/i18n/phonenumbers/PhoneNumberUtil.java#L3236-L3250\n      switch (checkNumberLength(nationalNumber, metadata)) {\n        case 'TOO_SHORT':\n        case 'INVALID_LENGTH':\n          // case 'IS_POSSIBLE_LOCAL_ONLY':\n          // Don't strip the national prefix.\n          return {\n            nationalNumber: number\n          };\n      }\n    }\n  }\n\n  return {\n    nationalNumber: nationalNumber,\n    carrierCode: carrierCode\n  };\n}\n/**\r\n * Converts a phone number digits (possibly with a `+`)\r\n * into a calling code and the rest phone number digits.\r\n * The \"rest phone number digits\" could include\r\n * a national prefix, carrier code, and national\r\n * (significant) number.\r\n * @param  {string} number — Phone number digits (possibly with a `+`).\r\n * @param  {string} [country] — Default country.\r\n * @param  {string} [callingCode] — Default calling code (some phone numbering plans are non-geographic).\r\n * @param  {object} metadata\r\n * @return {object} `{ countryCallingCode: string?, number: string }`\r\n * @example\r\n * // Returns `{ countryCallingCode: \"1\", number: \"2133734253\" }`.\r\n * extractCountryCallingCode('2133734253', 'US', null, metadata)\r\n * extractCountryCallingCode('2133734253', null, '1', metadata)\r\n * extractCountryCallingCode('+12133734253', null, null, metadata)\r\n * extractCountryCallingCode('+12133734253', 'RU', null, metadata)\r\n */\n\nexport function extractCountryCallingCode(number, country, callingCode, metadata) {\n  if (!number) {\n    return {};\n  } // If this is not an international phone number,\n  // then either extract an \"IDD\" prefix, or extract a\n  // country calling code from a number by autocorrecting it\n  // by prepending a leading `+` in cases when it starts\n  // with the country calling code.\n  // https://wikitravel.org/en/International_dialling_prefix\n  // https://github.com/catamphetamine/libphonenumber-js/issues/376\n\n\n  if (number[0] !== '+') {\n    // Convert an \"out-of-country\" dialing phone number\n    // to a proper international phone number.\n    var numberWithoutIDD = stripIDDPrefix(number, country, callingCode, metadata); // If an IDD prefix was stripped then\n    // convert the number to international one\n    // for subsequent parsing.\n\n    if (numberWithoutIDD && numberWithoutIDD !== number) {\n      number = '+' + numberWithoutIDD;\n    } else {\n      // Check to see if the number starts with the country calling code\n      // for the default country. If so, we remove the country calling code,\n      // and do some checks on the validity of the number before and after.\n      // https://github.com/catamphetamine/libphonenumber-js/issues/376\n      if (country || callingCode) {\n        var _extractCountryCallin2 = extractCountryCallingCodeFromInternationalNumberWithoutPlusSign(number, country, callingCode, metadata),\n            countryCallingCode = _extractCountryCallin2.countryCallingCode,\n            shorterNumber = _extractCountryCallin2.number;\n\n        if (countryCallingCode) {\n          return {\n            countryCallingCode: countryCallingCode,\n            number: shorterNumber\n          };\n        }\n      }\n\n      return {\n        number: number\n      };\n    }\n  } // Fast abortion: country codes do not begin with a '0'\n\n\n  if (number[1] === '0') {\n    return {};\n  }\n\n  metadata = new Metadata(metadata); // The thing with country phone codes\n  // is that they are orthogonal to each other\n  // i.e. there's no such country phone code A\n  // for which country phone code B exists\n  // where B starts with A.\n  // Therefore, while scanning digits,\n  // if a valid country code is found,\n  // that means that it is the country code.\n  //\n\n  var i = 2;\n\n  while (i - 1 <= MAX_LENGTH_COUNTRY_CODE && i <= number.length) {\n    var _countryCallingCode = number.slice(1, i);\n\n    if (metadata.hasCallingCode(_countryCallingCode)) {\n      metadata.selectNumberingPlan(_countryCallingCode);\n      return {\n        countryCallingCode: _countryCallingCode,\n        number: number.slice(i)\n      };\n    }\n\n    i++;\n  }\n\n  return {};\n}\n/**\r\n * Sometimes some people incorrectly input international phone numbers\r\n * without the leading `+`. This function corrects such input.\r\n * @param  {string} number — Phone number digits.\r\n * @param  {string?} country\r\n * @param  {string?} callingCode\r\n * @param  {object} metadata\r\n * @return {object} `{ countryCallingCode: string?, number: string }`.\r\n */\n\nexport function extractCountryCallingCodeFromInternationalNumberWithoutPlusSign(number, country, callingCode, metadata) {\n  var countryCallingCode = country ? getCountryCallingCode(country, metadata) : callingCode;\n\n  if (number.indexOf(countryCallingCode) === 0) {\n    metadata = new Metadata(metadata);\n    metadata.selectNumberingPlan(country, callingCode);\n    var possibleShorterNumber = number.slice(countryCallingCode.length);\n\n    var _extractNationalNumbe3 = extractNationalNumber(possibleShorterNumber, metadata),\n        possibleShorterNationalNumber = _extractNationalNumbe3.nationalNumber;\n\n    var _extractNationalNumbe4 = extractNationalNumber(number, metadata),\n        nationalNumber = _extractNationalNumbe4.nationalNumber; // If the number was not valid before but is valid now,\n    // or if it was too long before, we consider the number\n    // with the country calling code stripped to be a better result\n    // and keep that instead.\n    // For example, in Germany (+49), `49` is a valid area code,\n    // so if a number starts with `49`, it could be both a valid\n    // national German number or an international number without\n    // a leading `+`.\n\n\n    if (!matchesEntirely(nationalNumber, metadata.nationalNumberPattern()) && matchesEntirely(possibleShorterNationalNumber, metadata.nationalNumberPattern()) || checkNumberLength(nationalNumber, metadata) === 'TOO_LONG') {\n      return {\n        countryCallingCode: countryCallingCode,\n        number: possibleShorterNumber\n      };\n    }\n  }\n\n  return {\n    number: number\n  };\n}","map":{"version":3,"sources":["../source/parse_.js"],"names":["MAX_INPUT_STRING_LENGTH","PHONE_NUMBER_START_PATTERN","AFTER_PHONE_NUMBER_END_PATTERN","USE_NON_GEOGRAPHIC_COUNTRY_CODE","options","metadata","formattedPhoneNumber","ext","parseInput","country","nationalNumber","countryCallingCode","carrierCode","parsePhoneNumber","phoneNumber","valid","matchesEntirely","result","possible","isPossibleNumber","phone","text","startsAt","number","prefixPattern","prefixMatch","capturedGroupsCount","hasCapturedGroups","prefixBeforeNationalNumber","possiblePositionOfTheFirstCapturedGroup","possibleNationalPrefix","nationalPrefix","possibleCountries","_findCountryCode","nationalPhoneNumber","getNumberType","parseRFC3966","extractFormattedPhoneNumber","isViablePhoneNumber","withExtensionStripped","extractExtension","extractCountryCallingCode","parseIncompletePhoneNumber","defaultCountry","defaultCallingCode","getCountryCallingCode","extractNationalNumber","exactCountry","findCountryCode","extractNationalNumberFromPossiblyIncompleteNumber","shouldExtractNationalPrefix","checkNumberLength","numberWithoutIDD","stripIDDPrefix","shorterNumber","extractCountryCallingCodeFromInternationalNumberWithoutPlusSign","i","possibleShorterNumber","possibleShorterNationalNumber"],"mappings":"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","sourcesContent":["// This is a port of Google Android `libphonenumber`'s\r\n// `phonenumberutil.js` of December 31th, 2018.\r\n//\r\n// https://github.com/googlei18n/libphonenumber/commits/master/javascript/i18n/phonenumbers/phonenumberutil.js\r\n\r\nimport {\r\n\tVALID_DIGITS,\r\n\tPLUS_CHARS,\r\n\tMIN_LENGTH_FOR_NSN,\r\n\tMAX_LENGTH_FOR_NSN,\r\n\tMAX_LENGTH_COUNTRY_CODE\r\n} from './constants'\r\n\r\nimport { matchesEntirely } from './util'\r\nimport ParseError from './ParseError'\r\nimport Metadata from './metadata'\r\nimport isViablePhoneNumber from './isViablePhoneNumber'\r\nimport { extractExtension } from './extension'\r\nimport parseIncompletePhoneNumber from './parseIncompletePhoneNumber'\r\nimport getCountryCallingCode from './getCountryCallingCode'\r\nimport getNumberType from './getNumberType_'\r\nimport checkNumberLength from './checkNumberLength'\r\nimport { isPossibleNumber } from './isPossibleNumber_'\r\nimport { stripIDDPrefix } from './IDD'\r\nimport { parseRFC3966 } from './RFC3966'\r\nimport PhoneNumber from './PhoneNumber'\r\n\r\n// We don't allow input strings for parsing to be longer than 250 chars.\r\n// This prevents malicious input from consuming CPU.\r\nconst MAX_INPUT_STRING_LENGTH = 250\r\n\r\n// This consists of the plus symbol, digits, and arabic-indic digits.\r\nconst PHONE_NUMBER_START_PATTERN = new RegExp('[' + PLUS_CHARS + VALID_DIGITS + ']')\r\n\r\n// Regular expression of trailing characters that we want to remove.\r\n// A trailing `#` is sometimes used when writing phone numbers with extensions in US.\r\n// Example: \"+1 (645) 123 1234-910#\" number has extension \"910\".\r\nconst AFTER_PHONE_NUMBER_END_PATTERN = new RegExp('[^' + VALID_DIGITS + '#' + ']+$')\r\n\r\nconst USE_NON_GEOGRAPHIC_COUNTRY_CODE = false\r\n\r\n// `options`:\r\n//  {\r\n//    country:\r\n//    {\r\n//      restrict - (a two-letter country code)\r\n//                 the phone number must be in this country\r\n//\r\n//      default - (a two-letter country code)\r\n//                default country to use for phone number parsing and validation\r\n//                (if no country code could be derived from the phone number)\r\n//    }\r\n//  }\r\n//\r\n// Returns `{ country, number }`\r\n//\r\n// Example use cases:\r\n//\r\n// ```js\r\n// parse('8 (800) 555-35-35', 'RU')\r\n// parse('8 (800) 555-35-35', 'RU', metadata)\r\n// parse('8 (800) 555-35-35', { country: { default: 'RU' } })\r\n// parse('8 (800) 555-35-35', { country: { default: 'RU' } }, metadata)\r\n// parse('+7 800 555 35 35')\r\n// parse('+7 800 555 35 35', metadata)\r\n// ```\r\n//\r\nexport default function parse(text, options, metadata) {\r\n\t// If assigning the `{}` default value is moved to the arguments above,\r\n\t// code coverage would decrease for some weird reason.\r\n\toptions = options || {}\r\n\r\n\tmetadata = new Metadata(metadata)\r\n\r\n\t// Validate `defaultCountry`.\r\n\tif (options.defaultCountry && !metadata.hasCountry(options.defaultCountry)) {\r\n\t\tif (options.v2) {\r\n\t\t\tthrow new ParseError('INVALID_COUNTRY')\r\n\t\t}\r\n\t\tthrow new Error(`Unknown country: ${options.defaultCountry}`)\r\n\t}\r\n\r\n\t// Parse the phone number.\r\n\tconst { number: formattedPhoneNumber, ext } = parseInput(text, options.v2)\r\n\r\n\t// If the phone number is not viable then return nothing.\r\n\tif (!formattedPhoneNumber) {\r\n\t\tif (options.v2) {\r\n\t\t\tthrow new ParseError('NOT_A_NUMBER')\r\n\t\t}\r\n\t\treturn {}\r\n\t}\r\n\r\n\tconst {\r\n\t\tcountry,\r\n\t\tnationalNumber,\r\n\t\tcountryCallingCode,\r\n\t\tcarrierCode\r\n\t} = parsePhoneNumber(\r\n\t\tformattedPhoneNumber,\r\n\t\toptions.defaultCountry,\r\n\t\toptions.defaultCallingCode,\r\n\t\tmetadata\r\n\t)\r\n\r\n\tif (!metadata.hasSelectedNumberingPlan()) {\r\n\t\tif (options.v2) {\r\n\t\t\tthrow new ParseError('INVALID_COUNTRY')\r\n\t\t}\r\n\t\treturn {}\r\n\t}\r\n\r\n\t// Validate national (significant) number length.\r\n\tif (!nationalNumber || nationalNumber.length < MIN_LENGTH_FOR_NSN) {\r\n\t\t// Won't throw here because the regexp already demands length > 1.\r\n\t\t/* istanbul ignore if */\r\n\t\tif (options.v2) {\r\n\t\t\tthrow new ParseError('TOO_SHORT')\r\n\t\t}\r\n\t\t// Google's demo just throws an error in this case.\r\n\t\treturn {}\r\n\t}\r\n\r\n\t// Validate national (significant) number length.\r\n\t//\r\n\t// A sidenote:\r\n\t//\r\n\t// They say that sometimes national (significant) numbers\r\n\t// can be longer than `MAX_LENGTH_FOR_NSN` (e.g. in Germany).\r\n\t// https://github.com/googlei18n/libphonenumber/blob/7e1748645552da39c4e1ba731e47969d97bdb539/resources/phonenumber.proto#L36\r\n\t// Such numbers will just be discarded.\r\n\t//\r\n\tif (nationalNumber.length > MAX_LENGTH_FOR_NSN) {\r\n\t\tif (options.v2) {\r\n\t\t\tthrow new ParseError('TOO_LONG')\r\n\t\t}\r\n\t\t// Google's demo just throws an error in this case.\r\n\t\treturn {}\r\n\t}\r\n\r\n\tif (options.v2) {\r\n\t\tconst phoneNumber = new PhoneNumber(\r\n\t\t\tcountryCallingCode,\r\n\t\t\tnationalNumber,\r\n\t\t\tmetadata.metadata\r\n\t\t)\r\n\t\tif (country) {\r\n\t\t\tphoneNumber.country = country\r\n\t\t}\r\n\t\tif (carrierCode) {\r\n\t\t\tphoneNumber.carrierCode = carrierCode\r\n\t\t}\r\n\t\tif (ext) {\r\n\t\t\tphoneNumber.ext = ext\r\n\t\t}\r\n\t\treturn phoneNumber\r\n\t}\r\n\r\n\t// Check if national phone number pattern matches the number.\r\n\t// National number pattern is different for each country,\r\n\t// even for those ones which are part of the \"NANPA\" group.\r\n\tconst valid = (options.extended ? metadata.hasSelectedNumberingPlan() : country) ?\r\n\t\tmatchesEntirely(nationalNumber, metadata.nationalNumberPattern()) :\r\n\t\tfalse\r\n\r\n\tif (!options.extended) {\r\n\t\treturn valid ? result(country, nationalNumber, ext) : {}\r\n\t}\r\n\r\n\t// isInternational: countryCallingCode !== undefined\r\n\r\n\treturn {\r\n\t\tcountry,\r\n\t\tcountryCallingCode,\r\n\t\tcarrierCode,\r\n\t\tvalid,\r\n\t\tpossible: valid ? true : (\r\n\t\t\toptions.extended === true &&\r\n\t\t\tmetadata.possibleLengths() &&\r\n\t\t\tisPossibleNumber(nationalNumber, metadata) ? true : false\r\n\t\t),\r\n\t\tphone: nationalNumber,\r\n\t\text\r\n\t}\r\n}\r\n\r\n/**\r\n * Extracts a formatted phone number from text.\r\n * Doesn't guarantee that the extracted phone number\r\n * is a valid phone number (for example, doesn't validate its length).\r\n * @param  {string} text\r\n * @param  {boolean} throwOnError — By default, it won't throw if the text is too long.\r\n * @return {string}\r\n * @example\r\n * // Returns \"(213) 373-4253\".\r\n * extractFormattedPhoneNumber(\"Call (213) 373-4253 for assistance.\")\r\n */\r\nexport function extractFormattedPhoneNumber(text, throwOnError) {\r\n\tif (!text) {\r\n\t\treturn\r\n\t}\r\n\tif (text.length > MAX_INPUT_STRING_LENGTH) {\r\n\t\tif (throwOnError) {\r\n\t\t\tthrow new ParseError('TOO_LONG')\r\n\t\t}\r\n\t\treturn\r\n\t}\r\n\t// Attempt to extract a possible number from the string passed in\r\n\tconst startsAt = text.search(PHONE_NUMBER_START_PATTERN)\r\n\tif (startsAt < 0) {\r\n\t\treturn\r\n\t}\r\n\treturn text\r\n\t\t// Trim everything to the left of the phone number\r\n\t\t.slice(startsAt)\r\n\t\t// Remove trailing non-numerical characters\r\n\t\t.replace(AFTER_PHONE_NUMBER_END_PATTERN, '')\r\n}\r\n\r\n/**\r\n * Strips any national prefix (such as 0, 1) present in a\r\n * (possibly incomplete) number provided.\r\n * \"Carrier codes\" are only used  in Colombia and Brazil,\r\n * and only when dialing within those countries from a mobile phone to a fixed line number.\r\n * Sometimes it won't actually strip national prefix\r\n * and will instead prepend some digits to the `number`:\r\n * for example, when number `2345678` is passed with `VI` country selected,\r\n * it will return `{ number: \"3402345678\" }`, because `340` area code is prepended.\r\n * @param {string} number — National number digits.\r\n * @param {object} metadata — Metadata with country selected.\r\n * @return {object} `{ nationalNumber: string, nationalPrefix: string? carrierCode: string? }`.\r\n */\r\nexport function extractNationalNumberFromPossiblyIncompleteNumber(number, metadata) {\r\n\tif (number && metadata.numberingPlan.nationalPrefixForParsing()) {\r\n\t\t// See METADATA.md for the description of\r\n\t\t// `national_prefix_for_parsing` and `national_prefix_transform_rule`.\r\n\t\t// Attempt to parse the first digits as a national prefix.\r\n\t\tconst prefixPattern = new RegExp('^(?:' + metadata.numberingPlan.nationalPrefixForParsing() + ')')\r\n\t\tconst prefixMatch = prefixPattern.exec(number)\r\n\t\tif (prefixMatch) {\r\n\t\t\tlet nationalNumber\r\n\t\t\tlet carrierCode\r\n\t\t\t// https://gitlab.com/catamphetamine/libphonenumber-js/-/blob/master/METADATA.md#national_prefix_for_parsing--national_prefix_transform_rule\r\n\t\t\t// If a `national_prefix_for_parsing` has any \"capturing groups\"\r\n\t\t\t// then it means that the national (significant) number is equal to\r\n\t\t\t// those \"capturing groups\" transformed via `national_prefix_transform_rule`,\r\n\t\t\t// and nothing could be said about the actual national prefix:\r\n\t\t\t// what is it and was it even there.\r\n\t\t\t// If a `national_prefix_for_parsing` doesn't have any \"capturing groups\",\r\n\t\t\t// then everything it matches is a national prefix.\r\n\t\t\t// To determine whether `national_prefix_for_parsing` matched any\r\n\t\t\t// \"capturing groups\", the value of the result of calling `.exec()`\r\n\t\t\t// is looked at, and if it has non-undefined values where there're\r\n\t\t\t// \"capturing groups\" in the regular expression, then it means\r\n\t\t\t// that \"capturing groups\" have been matched.\r\n\t\t\t// It's not possible to tell whether there'll be any \"capturing gropus\"\r\n\t\t\t// before the matching process, because a `national_prefix_for_parsing`\r\n\t\t\t// could exhibit both behaviors.\r\n\t\t\tconst capturedGroupsCount = prefixMatch.length - 1\r\n\t\t\tconst hasCapturedGroups = capturedGroupsCount > 0 && prefixMatch[capturedGroupsCount]\r\n\t\t\tif (metadata.nationalPrefixTransformRule() && hasCapturedGroups) {\r\n\t\t\t\tnationalNumber = number.replace(\r\n\t\t\t\t\tprefixPattern,\r\n\t\t\t\t\tmetadata.nationalPrefixTransformRule()\r\n\t\t\t\t)\r\n\t\t\t\t// If there's more than one captured group,\r\n\t\t\t\t// then carrier code is the second one.\r\n\t\t\t\tif (capturedGroupsCount > 1) {\r\n\t\t\t\t\tcarrierCode = prefixMatch[1]\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t// If there're no \"capturing groups\",\r\n\t\t\t// or if there're \"capturing groups\" but no\r\n\t\t\t// `national_prefix_transform_rule`,\r\n\t\t\t// then just strip the national prefix from the number,\r\n\t\t\t// and possibly a carrier code.\r\n\t\t\t// Seems like there could be more.\r\n\t\t\telse {\r\n\t\t\t\t// `prefixBeforeNationalNumber` is the whole substring matched by\r\n\t\t\t\t// the `national_prefix_for_parsing` regular expression.\r\n\t\t\t\t// There seem to be no guarantees that it's just a national prefix.\r\n\t\t\t\t// For example, if there's a carrier code, it's gonna be a\r\n\t\t\t\t// part of `prefixBeforeNationalNumber` too.\r\n\t\t\t\tconst prefixBeforeNationalNumber = prefixMatch[0]\r\n\t\t\t\tnationalNumber = number.slice(prefixBeforeNationalNumber.length)\r\n\t\t\t\t// If there's at least one captured group,\r\n\t\t\t\t// then carrier code is the first one.\r\n\t\t\t\tif (hasCapturedGroups) {\r\n\t\t\t\t\tcarrierCode = prefixMatch[1]\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t// Tries to guess whether a national prefix was present in the input.\r\n\t\t\t// This is not something copy-pasted from Google's library:\r\n\t\t\t// they don't seem to have an equivalent for that.\r\n\t\t\t// So this isn't an \"officially approved\" way of doing something like that.\r\n\t\t\t// But since there seems no other existing method, this library uses it.\r\n\t\t\tlet nationalPrefix\r\n\t\t\tif (hasCapturedGroups) {\r\n\t\t\t\tconst possiblePositionOfTheFirstCapturedGroup = number.indexOf(prefixMatch[1])\r\n\t\t\t\tconst possibleNationalPrefix = number.slice(0, possiblePositionOfTheFirstCapturedGroup)\r\n\t\t\t\t// Example: an Argentinian (AR) phone number `0111523456789`.\r\n\t\t\t\t// `prefixMatch[0]` is `01115`, and `$1` is `11`,\r\n\t\t\t\t// and the rest of the phone number is `23456789`.\r\n\t\t\t\t// The national number is transformed via `9$1` to `91123456789`.\r\n\t\t\t\t// National prefix `0` is detected being present at the start.\r\n\t\t\t\t// if (possibleNationalPrefix.indexOf(metadata.numberingPlan.nationalPrefix()) === 0) {\r\n\t\t\t\tif (possibleNationalPrefix === metadata.numberingPlan.nationalPrefix()) {\r\n\t\t\t\t\tnationalPrefix = metadata.numberingPlan.nationalPrefix()\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tnationalPrefix = prefixMatch[0]\r\n\t\t\t}\r\n\t\t\treturn {\r\n\t\t\t\tnationalNumber,\r\n\t\t\t\tnationalPrefix,\r\n\t\t\t\tcarrierCode\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n   return {\r\n   \tnationalNumber: number\r\n   }\r\n}\r\n\r\n// In some countries, the same digit could be a national prefix\r\n// or a leading digit of a valid phone number.\r\n// For example, in Russia, national prefix is `8`,\r\n// and also `800 555 35 35` is a valid number\r\n// in which `8` is not a national prefix, but the first digit\r\n// of a national (significant) number.\r\n// Same's with Belarus:\r\n// `82004910060` is a valid national (significant) number,\r\n// but `2004910060` is not.\r\n// To support such cases (to prevent the code from always stripping\r\n// national prefix), a condition is imposed: a national prefix\r\n// is not extracted when the original number is \"viable\" and the\r\n// resultant number is not, a \"viable\" national number being the one\r\n// that matches `national_number_pattern`.\r\nfunction shouldExtractNationalPrefix(number, nationalSignificantNumber, metadata) {\r\n\t// The equivalent in Google's code is:\r\n\t// https://github.com/google/libphonenumber/blob/e326fa1fc4283bb05eb35cb3c15c18f98a31af33/java/libphonenumber/src/com/google/i18n/phonenumbers/PhoneNumberUtil.java#L2969-L3004\r\n\tif (matchesEntirely(number, metadata.nationalNumberPattern()) &&\r\n\t\t!matchesEntirely(nationalSignificantNumber, metadata.nationalNumberPattern())) {\r\n\t\treturn false\r\n\t}\r\n\t// Just \"possible\" number check would be more relaxed, so it's not used.\r\n\t// if (isPossibleNumber(number, metadata) &&\r\n\t// \t!isPossibleNumber(numberWithNationalPrefixExtracted, metadata)) {\r\n\t// \treturn false\r\n\t// }\r\n\treturn true\r\n}\r\n\r\nexport function findCountryCode(callingCode, nationalPhoneNumber, metadata) {\r\n\t/* istanbul ignore if */\r\n\tif (USE_NON_GEOGRAPHIC_COUNTRY_CODE) {\r\n\t\tif (metadata.isNonGeographicCallingCode(callingCode)) {\r\n\t\t\treturn '001'\r\n\t\t}\r\n\t}\r\n\t// Is always non-empty, because `callingCode` is always valid\r\n\tconst possibleCountries = metadata.getCountryCodesForCallingCode(callingCode)\r\n\tif (!possibleCountries) {\r\n\t\treturn\r\n\t}\r\n\t// If there's just one country corresponding to the country code,\r\n\t// then just return it, without further phone number digits validation.\r\n\tif (possibleCountries.length === 1) {\r\n\t\treturn possibleCountries[0]\r\n\t}\r\n\treturn _findCountryCode(possibleCountries, nationalPhoneNumber, metadata.metadata)\r\n}\r\n\r\n// Changes `metadata` `country`.\r\nfunction _findCountryCode(possibleCountries, nationalPhoneNumber, metadata) {\r\n\tmetadata = new Metadata(metadata)\r\n\tfor (const country of possibleCountries) {\r\n\t\tmetadata.country(country)\r\n\t\t// Leading digits check would be the simplest one\r\n\t\tif (metadata.leadingDigits()) {\r\n\t\t\tif (nationalPhoneNumber &&\r\n\t\t\t\tnationalPhoneNumber.search(metadata.leadingDigits()) === 0) {\r\n\t\t\t\treturn country\r\n\t\t\t}\r\n\t\t}\r\n\t\t// Else perform full validation with all of those\r\n\t\t// fixed-line/mobile/etc regular expressions.\r\n\t\telse if (getNumberType({ phone: nationalPhoneNumber, country }, undefined, metadata.metadata)) {\r\n\t\t\treturn country\r\n\t\t}\r\n\t}\r\n}\r\n\r\n/**\r\n * @param  {string} text - Input.\r\n * @return {object} `{ ?number, ?ext }`.\r\n */\r\nfunction parseInput(text, v2) {\r\n\t// Parse RFC 3966 phone number URI.\r\n\tif (text && text.indexOf('tel:') === 0) {\r\n\t\treturn parseRFC3966(text)\r\n\t}\r\n\tlet number = extractFormattedPhoneNumber(text, v2)\r\n\t// If the phone number is not viable, then abort.\r\n\tif (!number || !isViablePhoneNumber(number)) {\r\n\t\treturn {}\r\n\t}\r\n\t// Attempt to parse extension first, since it doesn't require region-specific\r\n\t// data and we want to have the non-normalised number here.\r\n\tconst withExtensionStripped = extractExtension(number)\r\n\tif (withExtensionStripped.ext) {\r\n\t\treturn withExtensionStripped\r\n\t}\r\n\treturn { number }\r\n}\r\n\r\n/**\r\n * Creates `parse()` result object.\r\n */\r\nfunction result(country, nationalNumber, ext) {\r\n\tconst result = {\r\n\t\tcountry,\r\n\t\tphone: nationalNumber\r\n\t}\r\n\tif (ext) {\r\n\t\tresult.ext = ext\r\n\t}\r\n\treturn result\r\n}\r\n\r\n/**\r\n * Parses a viable phone number.\r\n * @param {string} formattedPhoneNumber — Example: \"(213) 373-4253\".\r\n * @param {string} [defaultCountry]\r\n * @param {string} [defaultCallingCode]\r\n * @param {Metadata} metadata\r\n * @return {object} Returns `{ country: string?, countryCallingCode: string?, nationalNumber: string? }`.\r\n */\r\nfunction parsePhoneNumber(\r\n\tformattedPhoneNumber,\r\n\tdefaultCountry,\r\n\tdefaultCallingCode,\r\n\tmetadata\r\n) {\r\n\t// Extract calling code from phone number.\r\n\tlet { countryCallingCode, number } = extractCountryCallingCode(\r\n\t\tparseIncompletePhoneNumber(formattedPhoneNumber),\r\n\t\tdefaultCountry,\r\n\t\tdefaultCallingCode,\r\n\t\tmetadata.metadata\r\n\t)\r\n\r\n\t// Choose a country by `countryCallingCode`.\r\n\tlet country\r\n\tif (countryCallingCode) {\r\n\t\tmetadata.selectNumberingPlan(countryCallingCode)\r\n\t}\r\n\t// If `formattedPhoneNumber` is in \"national\" format\r\n\t// then `number` is defined and `countryCallingCode` isn't.\r\n\telse if (number && (defaultCountry || defaultCallingCode)) {\r\n\t\tmetadata.selectNumberingPlan(defaultCountry, defaultCallingCode)\r\n\t\tif (defaultCountry) {\r\n\t\t\tcountry = defaultCountry\r\n\t\t} else {\r\n\t\t\t/* istanbul ignore if */\r\n\t\t\tif (USE_NON_GEOGRAPHIC_COUNTRY_CODE) {\r\n\t\t\t\tif (metadata.isNonGeographicCallingCode(defaultCallingCode)) {\r\n\t\t\t\t\tcountry = '001'\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tcountryCallingCode = defaultCallingCode || getCountryCallingCode(defaultCountry, metadata.metadata)\r\n\t}\r\n\telse return {}\r\n\r\n\tif (!number) {\r\n\t\treturn { countryCallingCode }\r\n\t}\r\n\r\n\tconst {\r\n\t\tnationalNumber,\r\n\t\tcarrierCode\r\n\t} = extractNationalNumber(\r\n\t\tparseIncompletePhoneNumber(number),\r\n\t\tmetadata\r\n\t)\r\n\r\n\t// Sometimes there are several countries\r\n\t// corresponding to the same country phone code\r\n\t// (e.g. NANPA countries all having `1` country phone code).\r\n\t// Therefore, to reliably determine the exact country,\r\n\t// national (significant) number should have been parsed first.\r\n\t//\r\n\t// When `metadata.json` is generated, all \"ambiguous\" country phone codes\r\n\t// get their countries populated with the full set of\r\n\t// \"phone number type\" regular expressions.\r\n\t//\r\n\tconst exactCountry = findCountryCode(countryCallingCode, nationalNumber, metadata)\r\n\tif (exactCountry) {\r\n\t\tcountry = exactCountry\r\n\t\t/* istanbul ignore if */\r\n\t\tif (exactCountry === '001') {\r\n\t\t\t// Can't happen with `USE_NON_GEOGRAPHIC_COUNTRY_CODE` being `false`.\r\n\t\t\t// If `USE_NON_GEOGRAPHIC_COUNTRY_CODE` is set to `true` for some reason,\r\n\t\t\t// then remove the \"istanbul ignore if\".\r\n\t\t} else {\r\n\t\t\tmetadata.country(country)\r\n\t\t}\r\n\t}\r\n\r\n\treturn {\r\n\t\tcountry,\r\n\t\tcountryCallingCode,\r\n\t\tnationalNumber,\r\n\t\tcarrierCode\r\n\t}\r\n}\r\n\r\n/**\r\n * Strips national prefix and carrier code from a complete phone number.\r\n * The difference from the non-\"FromCompleteNumber\" function is that\r\n * it won't extract national prefix if the resultant number is too short\r\n * to be a complete number for the selected phone numbering plan.\r\n * @param  {string} number — Complete phone number digits.\r\n * @param  {Metadata} metadata — Metadata with a phone numbering plan selected.\r\n * @return {object} `{ nationalNumber: string, carrierCode: string? }`.\r\n */\r\nexport function extractNationalNumber(number, metadata) {\r\n\t// Parsing national prefixes and carrier codes\r\n\t// is only required for local phone numbers\r\n\t// but some people don't understand that\r\n\t// and sometimes write international phone numbers\r\n\t// with national prefixes (or maybe even carrier codes).\r\n\t// http://ucken.blogspot.ru/2016/03/trunk-prefixes-in-skype4b.html\r\n\t// Google's original library forgives such mistakes\r\n\t// and so does this library, because it has been requested:\r\n\t// https://github.com/catamphetamine/libphonenumber-js/issues/127\r\n\tconst {\r\n\t\tnationalNumber,\r\n\t\tcarrierCode\r\n\t} = extractNationalNumberFromPossiblyIncompleteNumber(\r\n\t\tnumber,\r\n\t\tmetadata\r\n\t)\r\n\tif (!shouldExtractNationalPrefix(number, nationalNumber, metadata)) {\r\n\t\t// Don't strip the national prefix.\r\n\t\treturn { nationalNumber: number }\r\n\t}\r\n\t// If a national prefix has been extracted, check to see\r\n\t// if the resultant number isn't too short.\r\n\t// Same code in Google's `libphonenumber`:\r\n\t// https://github.com/google/libphonenumber/blob/e326fa1fc4283bb05eb35cb3c15c18f98a31af33/java/libphonenumber/src/com/google/i18n/phonenumbers/PhoneNumberUtil.java#L3291-L3302\r\n\t// For some reason, they do this check right after the `national_number_pattern` check\r\n\t// this library does in `shouldExtractNationalPrefix()` function.\r\n\t// Why is there a second \"resultant\" number validity check?\r\n\t// They don't provide an explanation.\r\n\t// This library just copies the behavior.\r\n\tif (number.length !== nationalNumber.length + (carrierCode ? carrierCode.length : 0)) {\r\n\t\t// If not using legacy generated metadata (before version `1.0.18`)\r\n\t\t// then it has \"possible lengths\", so use those to validate the number length.\r\n\t\tif (metadata.possibleLengths()) {\r\n\t\t\t// \"We require that the NSN remaining after stripping the national prefix and\r\n\t\t\t// carrier code be long enough to be a possible length for the region.\r\n\t\t\t// Otherwise, we don't do the stripping, since the original number could be\r\n\t\t\t// a valid short number.\"\r\n\t\t\t// https://github.com/google/libphonenumber/blob/876268eb1ad6cdc1b7b5bef17fc5e43052702d57/java/libphonenumber/src/com/google/i18n/phonenumbers/PhoneNumberUtil.java#L3236-L3250\r\n\t\t\tswitch (checkNumberLength(nationalNumber, metadata)) {\r\n\t\t\t\tcase 'TOO_SHORT':\r\n\t\t\t\tcase 'INVALID_LENGTH':\r\n\t\t\t\t// case 'IS_POSSIBLE_LOCAL_ONLY':\r\n\t\t\t\t\t// Don't strip the national prefix.\r\n\t\t\t\t\treturn { nationalNumber: number }\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn { nationalNumber, carrierCode }\r\n}\r\n\r\n/**\r\n * Converts a phone number digits (possibly with a `+`)\r\n * into a calling code and the rest phone number digits.\r\n * The \"rest phone number digits\" could include\r\n * a national prefix, carrier code, and national\r\n * (significant) number.\r\n * @param  {string} number — Phone number digits (possibly with a `+`).\r\n * @param  {string} [country] — Default country.\r\n * @param  {string} [callingCode] — Default calling code (some phone numbering plans are non-geographic).\r\n * @param  {object} metadata\r\n * @return {object} `{ countryCallingCode: string?, number: string }`\r\n * @example\r\n * // Returns `{ countryCallingCode: \"1\", number: \"2133734253\" }`.\r\n * extractCountryCallingCode('2133734253', 'US', null, metadata)\r\n * extractCountryCallingCode('2133734253', null, '1', metadata)\r\n * extractCountryCallingCode('+12133734253', null, null, metadata)\r\n * extractCountryCallingCode('+12133734253', 'RU', null, metadata)\r\n */\r\nexport function extractCountryCallingCode(\r\n\tnumber,\r\n\tcountry,\r\n\tcallingCode,\r\n\tmetadata\r\n) {\r\n\tif (!number) {\r\n\t\treturn {}\r\n\t}\r\n\r\n\t// If this is not an international phone number,\r\n\t// then either extract an \"IDD\" prefix, or extract a\r\n\t// country calling code from a number by autocorrecting it\r\n\t// by prepending a leading `+` in cases when it starts\r\n\t// with the country calling code.\r\n\t// https://wikitravel.org/en/International_dialling_prefix\r\n\t// https://github.com/catamphetamine/libphonenumber-js/issues/376\r\n\tif (number[0] !== '+') {\r\n\t\t// Convert an \"out-of-country\" dialing phone number\r\n\t\t// to a proper international phone number.\r\n\t\tconst numberWithoutIDD = stripIDDPrefix(number, country, callingCode, metadata)\r\n\t\t// If an IDD prefix was stripped then\r\n\t\t// convert the number to international one\r\n\t\t// for subsequent parsing.\r\n\t\tif (numberWithoutIDD && numberWithoutIDD !== number) {\r\n\t\t\tnumber = '+' + numberWithoutIDD\r\n\t\t} else {\r\n\t\t\t// Check to see if the number starts with the country calling code\r\n\t\t\t// for the default country. If so, we remove the country calling code,\r\n\t\t\t// and do some checks on the validity of the number before and after.\r\n\t\t\t// https://github.com/catamphetamine/libphonenumber-js/issues/376\r\n\t\t\tif (country || callingCode) {\r\n\t\t\t\tconst {\r\n\t\t\t\t\tcountryCallingCode,\r\n\t\t\t\t\tnumber: shorterNumber\r\n\t\t\t\t} = extractCountryCallingCodeFromInternationalNumberWithoutPlusSign(\r\n\t\t\t\t\tnumber,\r\n\t\t\t\t\tcountry,\r\n\t\t\t\t\tcallingCode,\r\n\t\t\t\t\tmetadata\r\n\t\t\t\t)\r\n\t\t\t\tif (countryCallingCode) {\r\n\t\t\t\t\treturn {\r\n\t\t\t\t\t\tcountryCallingCode,\r\n\t\t\t\t\t\tnumber: shorterNumber\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn { number }\r\n\t\t}\r\n\t}\r\n\r\n\t// Fast abortion: country codes do not begin with a '0'\r\n\tif (number[1] === '0') {\r\n\t\treturn {}\r\n\t}\r\n\r\n\tmetadata = new Metadata(metadata)\r\n\r\n\t// The thing with country phone codes\r\n\t// is that they are orthogonal to each other\r\n\t// i.e. there's no such country phone code A\r\n\t// for which country phone code B exists\r\n\t// where B starts with A.\r\n\t// Therefore, while scanning digits,\r\n\t// if a valid country code is found,\r\n\t// that means that it is the country code.\r\n\t//\r\n\tlet i = 2\r\n\twhile (i - 1 <= MAX_LENGTH_COUNTRY_CODE && i <= number.length) {\r\n\t\tconst countryCallingCode = number.slice(1, i)\r\n\t\tif (metadata.hasCallingCode(countryCallingCode)) {\r\n\t\t\tmetadata.selectNumberingPlan(countryCallingCode)\r\n\t\t\treturn {\r\n\t\t\t\tcountryCallingCode,\r\n\t\t\t\tnumber: number.slice(i)\r\n\t\t\t}\r\n\t\t}\r\n\t\ti++\r\n\t}\r\n\r\n\treturn {}\r\n}\r\n\r\n/**\r\n * Sometimes some people incorrectly input international phone numbers\r\n * without the leading `+`. This function corrects such input.\r\n * @param  {string} number — Phone number digits.\r\n * @param  {string?} country\r\n * @param  {string?} callingCode\r\n * @param  {object} metadata\r\n * @return {object} `{ countryCallingCode: string?, number: string }`.\r\n */\r\nexport function extractCountryCallingCodeFromInternationalNumberWithoutPlusSign(\r\n\tnumber,\r\n\tcountry,\r\n\tcallingCode,\r\n\tmetadata\r\n) {\r\n\tconst countryCallingCode = country ? getCountryCallingCode(country, metadata) : callingCode\r\n\tif (number.indexOf(countryCallingCode) === 0) {\r\n\t\tmetadata = new Metadata(metadata)\r\n\t\tmetadata.selectNumberingPlan(country, callingCode)\r\n\t\tconst possibleShorterNumber = number.slice(countryCallingCode.length)\r\n\t\tconst {\r\n\t\t\tnationalNumber: possibleShorterNationalNumber,\r\n\t\t} = extractNationalNumber(\r\n\t\t\tpossibleShorterNumber,\r\n\t\t\tmetadata\r\n\t\t)\r\n\t\tconst {\r\n\t\t\tnationalNumber\r\n\t\t} = extractNationalNumber(\r\n\t\t\tnumber,\r\n\t\t\tmetadata\r\n\t\t)\r\n\t\t// If the number was not valid before but is valid now,\r\n\t\t// or if it was too long before, we consider the number\r\n\t\t// with the country calling code stripped to be a better result\r\n\t\t// and keep that instead.\r\n\t\t// For example, in Germany (+49), `49` is a valid area code,\r\n\t\t// so if a number starts with `49`, it could be both a valid\r\n\t\t// national German number or an international number without\r\n\t\t// a leading `+`.\r\n\t\tif (\r\n\t\t\t(\r\n\t\t\t\t!matchesEntirely(nationalNumber, metadata.nationalNumberPattern())\r\n\t\t\t\t&&\r\n\t\t\t\tmatchesEntirely(possibleShorterNationalNumber, metadata.nationalNumberPattern())\r\n\t\t\t)\r\n\t\t\t||\r\n\t\t\tcheckNumberLength(nationalNumber, metadata) === 'TOO_LONG'\r\n\t\t) {\r\n\t\t\treturn {\r\n\t\t\t\tcountryCallingCode,\r\n\t\t\t\tnumber: possibleShorterNumber\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn { number }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}