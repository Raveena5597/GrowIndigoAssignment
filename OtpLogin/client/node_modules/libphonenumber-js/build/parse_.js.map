{"version":3,"sources":["../source/parse_.js"],"names":["MAX_INPUT_STRING_LENGTH","PHONE_NUMBER_START_PATTERN","RegExp","PLUS_CHARS","VALID_DIGITS","AFTER_PHONE_NUMBER_END_PATTERN","USE_NON_GEOGRAPHIC_COUNTRY_CODE","parse","text","options","metadata","Metadata","defaultCountry","hasCountry","v2","ParseError","Error","parseInput","formattedPhoneNumber","number","ext","parsePhoneNumber","defaultCallingCode","country","nationalNumber","countryCallingCode","carrierCode","hasSelectedNumberingPlan","length","MIN_LENGTH_FOR_NSN","MAX_LENGTH_FOR_NSN","phoneNumber","PhoneNumber","valid","extended","nationalNumberPattern","result","possible","possibleLengths","phone","extractFormattedPhoneNumber","throwOnError","startsAt","search","slice","replace","extractNationalNumberFromPossiblyIncompleteNumber","numberingPlan","nationalPrefixForParsing","prefixPattern","prefixMatch","exec","capturedGroupsCount","hasCapturedGroups","nationalPrefixTransformRule","prefixBeforeNationalNumber","nationalPrefix","possiblePositionOfTheFirstCapturedGroup","indexOf","possibleNationalPrefix","shouldExtractNationalPrefix","nationalSignificantNumber","findCountryCode","callingCode","nationalPhoneNumber","isNonGeographicCallingCode","possibleCountries","getCountryCodesForCallingCode","_findCountryCode","leadingDigits","undefined","withExtensionStripped","extractCountryCallingCode","selectNumberingPlan","extractNationalNumber","exactCountry","numberWithoutIDD","extractCountryCallingCodeFromInternationalNumberWithoutPlusSign","shorterNumber","i","MAX_LENGTH_COUNTRY_CODE","hasCallingCode","possibleShorterNumber","possibleShorterNationalNumber"],"mappings":"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","sourcesContent":["// This is a port of Google Android `libphonenumber`'s\r\n// `phonenumberutil.js` of December 31th, 2018.\r\n//\r\n// https://github.com/googlei18n/libphonenumber/commits/master/javascript/i18n/phonenumbers/phonenumberutil.js\r\n\r\nimport {\r\n\tVALID_DIGITS,\r\n\tPLUS_CHARS,\r\n\tMIN_LENGTH_FOR_NSN,\r\n\tMAX_LENGTH_FOR_NSN,\r\n\tMAX_LENGTH_COUNTRY_CODE\r\n} from './constants'\r\n\r\nimport { matchesEntirely } from './util'\r\nimport ParseError from './ParseError'\r\nimport Metadata from './metadata'\r\nimport isViablePhoneNumber from './isViablePhoneNumber'\r\nimport { extractExtension } from './extension'\r\nimport parseIncompletePhoneNumber from './parseIncompletePhoneNumber'\r\nimport getCountryCallingCode from './getCountryCallingCode'\r\nimport getNumberType from './getNumberType_'\r\nimport checkNumberLength from './checkNumberLength'\r\nimport { isPossibleNumber } from './isPossibleNumber_'\r\nimport { stripIDDPrefix } from './IDD'\r\nimport { parseRFC3966 } from './RFC3966'\r\nimport PhoneNumber from './PhoneNumber'\r\n\r\n// We don't allow input strings for parsing to be longer than 250 chars.\r\n// This prevents malicious input from consuming CPU.\r\nconst MAX_INPUT_STRING_LENGTH = 250\r\n\r\n// This consists of the plus symbol, digits, and arabic-indic digits.\r\nconst PHONE_NUMBER_START_PATTERN = new RegExp('[' + PLUS_CHARS + VALID_DIGITS + ']')\r\n\r\n// Regular expression of trailing characters that we want to remove.\r\n// A trailing `#` is sometimes used when writing phone numbers with extensions in US.\r\n// Example: \"+1 (645) 123 1234-910#\" number has extension \"910\".\r\nconst AFTER_PHONE_NUMBER_END_PATTERN = new RegExp('[^' + VALID_DIGITS + '#' + ']+$')\r\n\r\nconst USE_NON_GEOGRAPHIC_COUNTRY_CODE = false\r\n\r\n// `options`:\r\n//  {\r\n//    country:\r\n//    {\r\n//      restrict - (a two-letter country code)\r\n//                 the phone number must be in this country\r\n//\r\n//      default - (a two-letter country code)\r\n//                default country to use for phone number parsing and validation\r\n//                (if no country code could be derived from the phone number)\r\n//    }\r\n//  }\r\n//\r\n// Returns `{ country, number }`\r\n//\r\n// Example use cases:\r\n//\r\n// ```js\r\n// parse('8 (800) 555-35-35', 'RU')\r\n// parse('8 (800) 555-35-35', 'RU', metadata)\r\n// parse('8 (800) 555-35-35', { country: { default: 'RU' } })\r\n// parse('8 (800) 555-35-35', { country: { default: 'RU' } }, metadata)\r\n// parse('+7 800 555 35 35')\r\n// parse('+7 800 555 35 35', metadata)\r\n// ```\r\n//\r\nexport default function parse(text, options, metadata) {\r\n\t// If assigning the `{}` default value is moved to the arguments above,\r\n\t// code coverage would decrease for some weird reason.\r\n\toptions = options || {}\r\n\r\n\tmetadata = new Metadata(metadata)\r\n\r\n\t// Validate `defaultCountry`.\r\n\tif (options.defaultCountry && !metadata.hasCountry(options.defaultCountry)) {\r\n\t\tif (options.v2) {\r\n\t\t\tthrow new ParseError('INVALID_COUNTRY')\r\n\t\t}\r\n\t\tthrow new Error(`Unknown country: ${options.defaultCountry}`)\r\n\t}\r\n\r\n\t// Parse the phone number.\r\n\tconst { number: formattedPhoneNumber, ext } = parseInput(text, options.v2)\r\n\r\n\t// If the phone number is not viable then return nothing.\r\n\tif (!formattedPhoneNumber) {\r\n\t\tif (options.v2) {\r\n\t\t\tthrow new ParseError('NOT_A_NUMBER')\r\n\t\t}\r\n\t\treturn {}\r\n\t}\r\n\r\n\tconst {\r\n\t\tcountry,\r\n\t\tnationalNumber,\r\n\t\tcountryCallingCode,\r\n\t\tcarrierCode\r\n\t} = parsePhoneNumber(\r\n\t\tformattedPhoneNumber,\r\n\t\toptions.defaultCountry,\r\n\t\toptions.defaultCallingCode,\r\n\t\tmetadata\r\n\t)\r\n\r\n\tif (!metadata.hasSelectedNumberingPlan()) {\r\n\t\tif (options.v2) {\r\n\t\t\tthrow new ParseError('INVALID_COUNTRY')\r\n\t\t}\r\n\t\treturn {}\r\n\t}\r\n\r\n\t// Validate national (significant) number length.\r\n\tif (!nationalNumber || nationalNumber.length < MIN_LENGTH_FOR_NSN) {\r\n\t\t// Won't throw here because the regexp already demands length > 1.\r\n\t\t/* istanbul ignore if */\r\n\t\tif (options.v2) {\r\n\t\t\tthrow new ParseError('TOO_SHORT')\r\n\t\t}\r\n\t\t// Google's demo just throws an error in this case.\r\n\t\treturn {}\r\n\t}\r\n\r\n\t// Validate national (significant) number length.\r\n\t//\r\n\t// A sidenote:\r\n\t//\r\n\t// They say that sometimes national (significant) numbers\r\n\t// can be longer than `MAX_LENGTH_FOR_NSN` (e.g. in Germany).\r\n\t// https://github.com/googlei18n/libphonenumber/blob/7e1748645552da39c4e1ba731e47969d97bdb539/resources/phonenumber.proto#L36\r\n\t// Such numbers will just be discarded.\r\n\t//\r\n\tif (nationalNumber.length > MAX_LENGTH_FOR_NSN) {\r\n\t\tif (options.v2) {\r\n\t\t\tthrow new ParseError('TOO_LONG')\r\n\t\t}\r\n\t\t// Google's demo just throws an error in this case.\r\n\t\treturn {}\r\n\t}\r\n\r\n\tif (options.v2) {\r\n\t\tconst phoneNumber = new PhoneNumber(\r\n\t\t\tcountryCallingCode,\r\n\t\t\tnationalNumber,\r\n\t\t\tmetadata.metadata\r\n\t\t)\r\n\t\tif (country) {\r\n\t\t\tphoneNumber.country = country\r\n\t\t}\r\n\t\tif (carrierCode) {\r\n\t\t\tphoneNumber.carrierCode = carrierCode\r\n\t\t}\r\n\t\tif (ext) {\r\n\t\t\tphoneNumber.ext = ext\r\n\t\t}\r\n\t\treturn phoneNumber\r\n\t}\r\n\r\n\t// Check if national phone number pattern matches the number.\r\n\t// National number pattern is different for each country,\r\n\t// even for those ones which are part of the \"NANPA\" group.\r\n\tconst valid = (options.extended ? metadata.hasSelectedNumberingPlan() : country) ?\r\n\t\tmatchesEntirely(nationalNumber, metadata.nationalNumberPattern()) :\r\n\t\tfalse\r\n\r\n\tif (!options.extended) {\r\n\t\treturn valid ? result(country, nationalNumber, ext) : {}\r\n\t}\r\n\r\n\t// isInternational: countryCallingCode !== undefined\r\n\r\n\treturn {\r\n\t\tcountry,\r\n\t\tcountryCallingCode,\r\n\t\tcarrierCode,\r\n\t\tvalid,\r\n\t\tpossible: valid ? true : (\r\n\t\t\toptions.extended === true &&\r\n\t\t\tmetadata.possibleLengths() &&\r\n\t\t\tisPossibleNumber(nationalNumber, metadata) ? true : false\r\n\t\t),\r\n\t\tphone: nationalNumber,\r\n\t\text\r\n\t}\r\n}\r\n\r\n/**\r\n * Extracts a formatted phone number from text.\r\n * Doesn't guarantee that the extracted phone number\r\n * is a valid phone number (for example, doesn't validate its length).\r\n * @param  {string} text\r\n * @param  {boolean} throwOnError — By default, it won't throw if the text is too long.\r\n * @return {string}\r\n * @example\r\n * // Returns \"(213) 373-4253\".\r\n * extractFormattedPhoneNumber(\"Call (213) 373-4253 for assistance.\")\r\n */\r\nexport function extractFormattedPhoneNumber(text, throwOnError) {\r\n\tif (!text) {\r\n\t\treturn\r\n\t}\r\n\tif (text.length > MAX_INPUT_STRING_LENGTH) {\r\n\t\tif (throwOnError) {\r\n\t\t\tthrow new ParseError('TOO_LONG')\r\n\t\t}\r\n\t\treturn\r\n\t}\r\n\t// Attempt to extract a possible number from the string passed in\r\n\tconst startsAt = text.search(PHONE_NUMBER_START_PATTERN)\r\n\tif (startsAt < 0) {\r\n\t\treturn\r\n\t}\r\n\treturn text\r\n\t\t// Trim everything to the left of the phone number\r\n\t\t.slice(startsAt)\r\n\t\t// Remove trailing non-numerical characters\r\n\t\t.replace(AFTER_PHONE_NUMBER_END_PATTERN, '')\r\n}\r\n\r\n/**\r\n * Strips any national prefix (such as 0, 1) present in a\r\n * (possibly incomplete) number provided.\r\n * \"Carrier codes\" are only used  in Colombia and Brazil,\r\n * and only when dialing within those countries from a mobile phone to a fixed line number.\r\n * Sometimes it won't actually strip national prefix\r\n * and will instead prepend some digits to the `number`:\r\n * for example, when number `2345678` is passed with `VI` country selected,\r\n * it will return `{ number: \"3402345678\" }`, because `340` area code is prepended.\r\n * @param {string} number — National number digits.\r\n * @param {object} metadata — Metadata with country selected.\r\n * @return {object} `{ nationalNumber: string, nationalPrefix: string? carrierCode: string? }`.\r\n */\r\nexport function extractNationalNumberFromPossiblyIncompleteNumber(number, metadata) {\r\n\tif (number && metadata.numberingPlan.nationalPrefixForParsing()) {\r\n\t\t// See METADATA.md for the description of\r\n\t\t// `national_prefix_for_parsing` and `national_prefix_transform_rule`.\r\n\t\t// Attempt to parse the first digits as a national prefix.\r\n\t\tconst prefixPattern = new RegExp('^(?:' + metadata.numberingPlan.nationalPrefixForParsing() + ')')\r\n\t\tconst prefixMatch = prefixPattern.exec(number)\r\n\t\tif (prefixMatch) {\r\n\t\t\tlet nationalNumber\r\n\t\t\tlet carrierCode\r\n\t\t\t// https://gitlab.com/catamphetamine/libphonenumber-js/-/blob/master/METADATA.md#national_prefix_for_parsing--national_prefix_transform_rule\r\n\t\t\t// If a `national_prefix_for_parsing` has any \"capturing groups\"\r\n\t\t\t// then it means that the national (significant) number is equal to\r\n\t\t\t// those \"capturing groups\" transformed via `national_prefix_transform_rule`,\r\n\t\t\t// and nothing could be said about the actual national prefix:\r\n\t\t\t// what is it and was it even there.\r\n\t\t\t// If a `national_prefix_for_parsing` doesn't have any \"capturing groups\",\r\n\t\t\t// then everything it matches is a national prefix.\r\n\t\t\t// To determine whether `national_prefix_for_parsing` matched any\r\n\t\t\t// \"capturing groups\", the value of the result of calling `.exec()`\r\n\t\t\t// is looked at, and if it has non-undefined values where there're\r\n\t\t\t// \"capturing groups\" in the regular expression, then it means\r\n\t\t\t// that \"capturing groups\" have been matched.\r\n\t\t\t// It's not possible to tell whether there'll be any \"capturing gropus\"\r\n\t\t\t// before the matching process, because a `national_prefix_for_parsing`\r\n\t\t\t// could exhibit both behaviors.\r\n\t\t\tconst capturedGroupsCount = prefixMatch.length - 1\r\n\t\t\tconst hasCapturedGroups = capturedGroupsCount > 0 && prefixMatch[capturedGroupsCount]\r\n\t\t\tif (metadata.nationalPrefixTransformRule() && hasCapturedGroups) {\r\n\t\t\t\tnationalNumber = number.replace(\r\n\t\t\t\t\tprefixPattern,\r\n\t\t\t\t\tmetadata.nationalPrefixTransformRule()\r\n\t\t\t\t)\r\n\t\t\t\t// If there's more than one captured group,\r\n\t\t\t\t// then carrier code is the second one.\r\n\t\t\t\tif (capturedGroupsCount > 1) {\r\n\t\t\t\t\tcarrierCode = prefixMatch[1]\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t// If there're no \"capturing groups\",\r\n\t\t\t// or if there're \"capturing groups\" but no\r\n\t\t\t// `national_prefix_transform_rule`,\r\n\t\t\t// then just strip the national prefix from the number,\r\n\t\t\t// and possibly a carrier code.\r\n\t\t\t// Seems like there could be more.\r\n\t\t\telse {\r\n\t\t\t\t// `prefixBeforeNationalNumber` is the whole substring matched by\r\n\t\t\t\t// the `national_prefix_for_parsing` regular expression.\r\n\t\t\t\t// There seem to be no guarantees that it's just a national prefix.\r\n\t\t\t\t// For example, if there's a carrier code, it's gonna be a\r\n\t\t\t\t// part of `prefixBeforeNationalNumber` too.\r\n\t\t\t\tconst prefixBeforeNationalNumber = prefixMatch[0]\r\n\t\t\t\tnationalNumber = number.slice(prefixBeforeNationalNumber.length)\r\n\t\t\t\t// If there's at least one captured group,\r\n\t\t\t\t// then carrier code is the first one.\r\n\t\t\t\tif (hasCapturedGroups) {\r\n\t\t\t\t\tcarrierCode = prefixMatch[1]\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t// Tries to guess whether a national prefix was present in the input.\r\n\t\t\t// This is not something copy-pasted from Google's library:\r\n\t\t\t// they don't seem to have an equivalent for that.\r\n\t\t\t// So this isn't an \"officially approved\" way of doing something like that.\r\n\t\t\t// But since there seems no other existing method, this library uses it.\r\n\t\t\tlet nationalPrefix\r\n\t\t\tif (hasCapturedGroups) {\r\n\t\t\t\tconst possiblePositionOfTheFirstCapturedGroup = number.indexOf(prefixMatch[1])\r\n\t\t\t\tconst possibleNationalPrefix = number.slice(0, possiblePositionOfTheFirstCapturedGroup)\r\n\t\t\t\t// Example: an Argentinian (AR) phone number `0111523456789`.\r\n\t\t\t\t// `prefixMatch[0]` is `01115`, and `$1` is `11`,\r\n\t\t\t\t// and the rest of the phone number is `23456789`.\r\n\t\t\t\t// The national number is transformed via `9$1` to `91123456789`.\r\n\t\t\t\t// National prefix `0` is detected being present at the start.\r\n\t\t\t\t// if (possibleNationalPrefix.indexOf(metadata.numberingPlan.nationalPrefix()) === 0) {\r\n\t\t\t\tif (possibleNationalPrefix === metadata.numberingPlan.nationalPrefix()) {\r\n\t\t\t\t\tnationalPrefix = metadata.numberingPlan.nationalPrefix()\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tnationalPrefix = prefixMatch[0]\r\n\t\t\t}\r\n\t\t\treturn {\r\n\t\t\t\tnationalNumber,\r\n\t\t\t\tnationalPrefix,\r\n\t\t\t\tcarrierCode\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n   return {\r\n   \tnationalNumber: number\r\n   }\r\n}\r\n\r\n// In some countries, the same digit could be a national prefix\r\n// or a leading digit of a valid phone number.\r\n// For example, in Russia, national prefix is `8`,\r\n// and also `800 555 35 35` is a valid number\r\n// in which `8` is not a national prefix, but the first digit\r\n// of a national (significant) number.\r\n// Same's with Belarus:\r\n// `82004910060` is a valid national (significant) number,\r\n// but `2004910060` is not.\r\n// To support such cases (to prevent the code from always stripping\r\n// national prefix), a condition is imposed: a national prefix\r\n// is not extracted when the original number is \"viable\" and the\r\n// resultant number is not, a \"viable\" national number being the one\r\n// that matches `national_number_pattern`.\r\nfunction shouldExtractNationalPrefix(number, nationalSignificantNumber, metadata) {\r\n\t// The equivalent in Google's code is:\r\n\t// https://github.com/google/libphonenumber/blob/e326fa1fc4283bb05eb35cb3c15c18f98a31af33/java/libphonenumber/src/com/google/i18n/phonenumbers/PhoneNumberUtil.java#L2969-L3004\r\n\tif (matchesEntirely(number, metadata.nationalNumberPattern()) &&\r\n\t\t!matchesEntirely(nationalSignificantNumber, metadata.nationalNumberPattern())) {\r\n\t\treturn false\r\n\t}\r\n\t// Just \"possible\" number check would be more relaxed, so it's not used.\r\n\t// if (isPossibleNumber(number, metadata) &&\r\n\t// \t!isPossibleNumber(numberWithNationalPrefixExtracted, metadata)) {\r\n\t// \treturn false\r\n\t// }\r\n\treturn true\r\n}\r\n\r\nexport function findCountryCode(callingCode, nationalPhoneNumber, metadata) {\r\n\t/* istanbul ignore if */\r\n\tif (USE_NON_GEOGRAPHIC_COUNTRY_CODE) {\r\n\t\tif (metadata.isNonGeographicCallingCode(callingCode)) {\r\n\t\t\treturn '001'\r\n\t\t}\r\n\t}\r\n\t// Is always non-empty, because `callingCode` is always valid\r\n\tconst possibleCountries = metadata.getCountryCodesForCallingCode(callingCode)\r\n\tif (!possibleCountries) {\r\n\t\treturn\r\n\t}\r\n\t// If there's just one country corresponding to the country code,\r\n\t// then just return it, without further phone number digits validation.\r\n\tif (possibleCountries.length === 1) {\r\n\t\treturn possibleCountries[0]\r\n\t}\r\n\treturn _findCountryCode(possibleCountries, nationalPhoneNumber, metadata.metadata)\r\n}\r\n\r\n// Changes `metadata` `country`.\r\nfunction _findCountryCode(possibleCountries, nationalPhoneNumber, metadata) {\r\n\tmetadata = new Metadata(metadata)\r\n\tfor (const country of possibleCountries) {\r\n\t\tmetadata.country(country)\r\n\t\t// Leading digits check would be the simplest one\r\n\t\tif (metadata.leadingDigits()) {\r\n\t\t\tif (nationalPhoneNumber &&\r\n\t\t\t\tnationalPhoneNumber.search(metadata.leadingDigits()) === 0) {\r\n\t\t\t\treturn country\r\n\t\t\t}\r\n\t\t}\r\n\t\t// Else perform full validation with all of those\r\n\t\t// fixed-line/mobile/etc regular expressions.\r\n\t\telse if (getNumberType({ phone: nationalPhoneNumber, country }, undefined, metadata.metadata)) {\r\n\t\t\treturn country\r\n\t\t}\r\n\t}\r\n}\r\n\r\n/**\r\n * @param  {string} text - Input.\r\n * @return {object} `{ ?number, ?ext }`.\r\n */\r\nfunction parseInput(text, v2) {\r\n\t// Parse RFC 3966 phone number URI.\r\n\tif (text && text.indexOf('tel:') === 0) {\r\n\t\treturn parseRFC3966(text)\r\n\t}\r\n\tlet number = extractFormattedPhoneNumber(text, v2)\r\n\t// If the phone number is not viable, then abort.\r\n\tif (!number || !isViablePhoneNumber(number)) {\r\n\t\treturn {}\r\n\t}\r\n\t// Attempt to parse extension first, since it doesn't require region-specific\r\n\t// data and we want to have the non-normalised number here.\r\n\tconst withExtensionStripped = extractExtension(number)\r\n\tif (withExtensionStripped.ext) {\r\n\t\treturn withExtensionStripped\r\n\t}\r\n\treturn { number }\r\n}\r\n\r\n/**\r\n * Creates `parse()` result object.\r\n */\r\nfunction result(country, nationalNumber, ext) {\r\n\tconst result = {\r\n\t\tcountry,\r\n\t\tphone: nationalNumber\r\n\t}\r\n\tif (ext) {\r\n\t\tresult.ext = ext\r\n\t}\r\n\treturn result\r\n}\r\n\r\n/**\r\n * Parses a viable phone number.\r\n * @param {string} formattedPhoneNumber — Example: \"(213) 373-4253\".\r\n * @param {string} [defaultCountry]\r\n * @param {string} [defaultCallingCode]\r\n * @param {Metadata} metadata\r\n * @return {object} Returns `{ country: string?, countryCallingCode: string?, nationalNumber: string? }`.\r\n */\r\nfunction parsePhoneNumber(\r\n\tformattedPhoneNumber,\r\n\tdefaultCountry,\r\n\tdefaultCallingCode,\r\n\tmetadata\r\n) {\r\n\t// Extract calling code from phone number.\r\n\tlet { countryCallingCode, number } = extractCountryCallingCode(\r\n\t\tparseIncompletePhoneNumber(formattedPhoneNumber),\r\n\t\tdefaultCountry,\r\n\t\tdefaultCallingCode,\r\n\t\tmetadata.metadata\r\n\t)\r\n\r\n\t// Choose a country by `countryCallingCode`.\r\n\tlet country\r\n\tif (countryCallingCode) {\r\n\t\tmetadata.selectNumberingPlan(countryCallingCode)\r\n\t}\r\n\t// If `formattedPhoneNumber` is in \"national\" format\r\n\t// then `number` is defined and `countryCallingCode` isn't.\r\n\telse if (number && (defaultCountry || defaultCallingCode)) {\r\n\t\tmetadata.selectNumberingPlan(defaultCountry, defaultCallingCode)\r\n\t\tif (defaultCountry) {\r\n\t\t\tcountry = defaultCountry\r\n\t\t} else {\r\n\t\t\t/* istanbul ignore if */\r\n\t\t\tif (USE_NON_GEOGRAPHIC_COUNTRY_CODE) {\r\n\t\t\t\tif (metadata.isNonGeographicCallingCode(defaultCallingCode)) {\r\n\t\t\t\t\tcountry = '001'\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tcountryCallingCode = defaultCallingCode || getCountryCallingCode(defaultCountry, metadata.metadata)\r\n\t}\r\n\telse return {}\r\n\r\n\tif (!number) {\r\n\t\treturn { countryCallingCode }\r\n\t}\r\n\r\n\tconst {\r\n\t\tnationalNumber,\r\n\t\tcarrierCode\r\n\t} = extractNationalNumber(\r\n\t\tparseIncompletePhoneNumber(number),\r\n\t\tmetadata\r\n\t)\r\n\r\n\t// Sometimes there are several countries\r\n\t// corresponding to the same country phone code\r\n\t// (e.g. NANPA countries all having `1` country phone code).\r\n\t// Therefore, to reliably determine the exact country,\r\n\t// national (significant) number should have been parsed first.\r\n\t//\r\n\t// When `metadata.json` is generated, all \"ambiguous\" country phone codes\r\n\t// get their countries populated with the full set of\r\n\t// \"phone number type\" regular expressions.\r\n\t//\r\n\tconst exactCountry = findCountryCode(countryCallingCode, nationalNumber, metadata)\r\n\tif (exactCountry) {\r\n\t\tcountry = exactCountry\r\n\t\t/* istanbul ignore if */\r\n\t\tif (exactCountry === '001') {\r\n\t\t\t// Can't happen with `USE_NON_GEOGRAPHIC_COUNTRY_CODE` being `false`.\r\n\t\t\t// If `USE_NON_GEOGRAPHIC_COUNTRY_CODE` is set to `true` for some reason,\r\n\t\t\t// then remove the \"istanbul ignore if\".\r\n\t\t} else {\r\n\t\t\tmetadata.country(country)\r\n\t\t}\r\n\t}\r\n\r\n\treturn {\r\n\t\tcountry,\r\n\t\tcountryCallingCode,\r\n\t\tnationalNumber,\r\n\t\tcarrierCode\r\n\t}\r\n}\r\n\r\n/**\r\n * Strips national prefix and carrier code from a complete phone number.\r\n * The difference from the non-\"FromCompleteNumber\" function is that\r\n * it won't extract national prefix if the resultant number is too short\r\n * to be a complete number for the selected phone numbering plan.\r\n * @param  {string} number — Complete phone number digits.\r\n * @param  {Metadata} metadata — Metadata with a phone numbering plan selected.\r\n * @return {object} `{ nationalNumber: string, carrierCode: string? }`.\r\n */\r\nexport function extractNationalNumber(number, metadata) {\r\n\t// Parsing national prefixes and carrier codes\r\n\t// is only required for local phone numbers\r\n\t// but some people don't understand that\r\n\t// and sometimes write international phone numbers\r\n\t// with national prefixes (or maybe even carrier codes).\r\n\t// http://ucken.blogspot.ru/2016/03/trunk-prefixes-in-skype4b.html\r\n\t// Google's original library forgives such mistakes\r\n\t// and so does this library, because it has been requested:\r\n\t// https://github.com/catamphetamine/libphonenumber-js/issues/127\r\n\tconst {\r\n\t\tnationalNumber,\r\n\t\tcarrierCode\r\n\t} = extractNationalNumberFromPossiblyIncompleteNumber(\r\n\t\tnumber,\r\n\t\tmetadata\r\n\t)\r\n\tif (!shouldExtractNationalPrefix(number, nationalNumber, metadata)) {\r\n\t\t// Don't strip the national prefix.\r\n\t\treturn { nationalNumber: number }\r\n\t}\r\n\t// If a national prefix has been extracted, check to see\r\n\t// if the resultant number isn't too short.\r\n\t// Same code in Google's `libphonenumber`:\r\n\t// https://github.com/google/libphonenumber/blob/e326fa1fc4283bb05eb35cb3c15c18f98a31af33/java/libphonenumber/src/com/google/i18n/phonenumbers/PhoneNumberUtil.java#L3291-L3302\r\n\t// For some reason, they do this check right after the `national_number_pattern` check\r\n\t// this library does in `shouldExtractNationalPrefix()` function.\r\n\t// Why is there a second \"resultant\" number validity check?\r\n\t// They don't provide an explanation.\r\n\t// This library just copies the behavior.\r\n\tif (number.length !== nationalNumber.length + (carrierCode ? carrierCode.length : 0)) {\r\n\t\t// If not using legacy generated metadata (before version `1.0.18`)\r\n\t\t// then it has \"possible lengths\", so use those to validate the number length.\r\n\t\tif (metadata.possibleLengths()) {\r\n\t\t\t// \"We require that the NSN remaining after stripping the national prefix and\r\n\t\t\t// carrier code be long enough to be a possible length for the region.\r\n\t\t\t// Otherwise, we don't do the stripping, since the original number could be\r\n\t\t\t// a valid short number.\"\r\n\t\t\t// https://github.com/google/libphonenumber/blob/876268eb1ad6cdc1b7b5bef17fc5e43052702d57/java/libphonenumber/src/com/google/i18n/phonenumbers/PhoneNumberUtil.java#L3236-L3250\r\n\t\t\tswitch (checkNumberLength(nationalNumber, metadata)) {\r\n\t\t\t\tcase 'TOO_SHORT':\r\n\t\t\t\tcase 'INVALID_LENGTH':\r\n\t\t\t\t// case 'IS_POSSIBLE_LOCAL_ONLY':\r\n\t\t\t\t\t// Don't strip the national prefix.\r\n\t\t\t\t\treturn { nationalNumber: number }\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn { nationalNumber, carrierCode }\r\n}\r\n\r\n/**\r\n * Converts a phone number digits (possibly with a `+`)\r\n * into a calling code and the rest phone number digits.\r\n * The \"rest phone number digits\" could include\r\n * a national prefix, carrier code, and national\r\n * (significant) number.\r\n * @param  {string} number — Phone number digits (possibly with a `+`).\r\n * @param  {string} [country] — Default country.\r\n * @param  {string} [callingCode] — Default calling code (some phone numbering plans are non-geographic).\r\n * @param  {object} metadata\r\n * @return {object} `{ countryCallingCode: string?, number: string }`\r\n * @example\r\n * // Returns `{ countryCallingCode: \"1\", number: \"2133734253\" }`.\r\n * extractCountryCallingCode('2133734253', 'US', null, metadata)\r\n * extractCountryCallingCode('2133734253', null, '1', metadata)\r\n * extractCountryCallingCode('+12133734253', null, null, metadata)\r\n * extractCountryCallingCode('+12133734253', 'RU', null, metadata)\r\n */\r\nexport function extractCountryCallingCode(\r\n\tnumber,\r\n\tcountry,\r\n\tcallingCode,\r\n\tmetadata\r\n) {\r\n\tif (!number) {\r\n\t\treturn {}\r\n\t}\r\n\r\n\t// If this is not an international phone number,\r\n\t// then either extract an \"IDD\" prefix, or extract a\r\n\t// country calling code from a number by autocorrecting it\r\n\t// by prepending a leading `+` in cases when it starts\r\n\t// with the country calling code.\r\n\t// https://wikitravel.org/en/International_dialling_prefix\r\n\t// https://github.com/catamphetamine/libphonenumber-js/issues/376\r\n\tif (number[0] !== '+') {\r\n\t\t// Convert an \"out-of-country\" dialing phone number\r\n\t\t// to a proper international phone number.\r\n\t\tconst numberWithoutIDD = stripIDDPrefix(number, country, callingCode, metadata)\r\n\t\t// If an IDD prefix was stripped then\r\n\t\t// convert the number to international one\r\n\t\t// for subsequent parsing.\r\n\t\tif (numberWithoutIDD && numberWithoutIDD !== number) {\r\n\t\t\tnumber = '+' + numberWithoutIDD\r\n\t\t} else {\r\n\t\t\t// Check to see if the number starts with the country calling code\r\n\t\t\t// for the default country. If so, we remove the country calling code,\r\n\t\t\t// and do some checks on the validity of the number before and after.\r\n\t\t\t// https://github.com/catamphetamine/libphonenumber-js/issues/376\r\n\t\t\tif (country || callingCode) {\r\n\t\t\t\tconst {\r\n\t\t\t\t\tcountryCallingCode,\r\n\t\t\t\t\tnumber: shorterNumber\r\n\t\t\t\t} = extractCountryCallingCodeFromInternationalNumberWithoutPlusSign(\r\n\t\t\t\t\tnumber,\r\n\t\t\t\t\tcountry,\r\n\t\t\t\t\tcallingCode,\r\n\t\t\t\t\tmetadata\r\n\t\t\t\t)\r\n\t\t\t\tif (countryCallingCode) {\r\n\t\t\t\t\treturn {\r\n\t\t\t\t\t\tcountryCallingCode,\r\n\t\t\t\t\t\tnumber: shorterNumber\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn { number }\r\n\t\t}\r\n\t}\r\n\r\n\t// Fast abortion: country codes do not begin with a '0'\r\n\tif (number[1] === '0') {\r\n\t\treturn {}\r\n\t}\r\n\r\n\tmetadata = new Metadata(metadata)\r\n\r\n\t// The thing with country phone codes\r\n\t// is that they are orthogonal to each other\r\n\t// i.e. there's no such country phone code A\r\n\t// for which country phone code B exists\r\n\t// where B starts with A.\r\n\t// Therefore, while scanning digits,\r\n\t// if a valid country code is found,\r\n\t// that means that it is the country code.\r\n\t//\r\n\tlet i = 2\r\n\twhile (i - 1 <= MAX_LENGTH_COUNTRY_CODE && i <= number.length) {\r\n\t\tconst countryCallingCode = number.slice(1, i)\r\n\t\tif (metadata.hasCallingCode(countryCallingCode)) {\r\n\t\t\tmetadata.selectNumberingPlan(countryCallingCode)\r\n\t\t\treturn {\r\n\t\t\t\tcountryCallingCode,\r\n\t\t\t\tnumber: number.slice(i)\r\n\t\t\t}\r\n\t\t}\r\n\t\ti++\r\n\t}\r\n\r\n\treturn {}\r\n}\r\n\r\n/**\r\n * Sometimes some people incorrectly input international phone numbers\r\n * without the leading `+`. This function corrects such input.\r\n * @param  {string} number — Phone number digits.\r\n * @param  {string?} country\r\n * @param  {string?} callingCode\r\n * @param  {object} metadata\r\n * @return {object} `{ countryCallingCode: string?, number: string }`.\r\n */\r\nexport function extractCountryCallingCodeFromInternationalNumberWithoutPlusSign(\r\n\tnumber,\r\n\tcountry,\r\n\tcallingCode,\r\n\tmetadata\r\n) {\r\n\tconst countryCallingCode = country ? getCountryCallingCode(country, metadata) : callingCode\r\n\tif (number.indexOf(countryCallingCode) === 0) {\r\n\t\tmetadata = new Metadata(metadata)\r\n\t\tmetadata.selectNumberingPlan(country, callingCode)\r\n\t\tconst possibleShorterNumber = number.slice(countryCallingCode.length)\r\n\t\tconst {\r\n\t\t\tnationalNumber: possibleShorterNationalNumber,\r\n\t\t} = extractNationalNumber(\r\n\t\t\tpossibleShorterNumber,\r\n\t\t\tmetadata\r\n\t\t)\r\n\t\tconst {\r\n\t\t\tnationalNumber\r\n\t\t} = extractNationalNumber(\r\n\t\t\tnumber,\r\n\t\t\tmetadata\r\n\t\t)\r\n\t\t// If the number was not valid before but is valid now,\r\n\t\t// or if it was too long before, we consider the number\r\n\t\t// with the country calling code stripped to be a better result\r\n\t\t// and keep that instead.\r\n\t\t// For example, in Germany (+49), `49` is a valid area code,\r\n\t\t// so if a number starts with `49`, it could be both a valid\r\n\t\t// national German number or an international number without\r\n\t\t// a leading `+`.\r\n\t\tif (\r\n\t\t\t(\r\n\t\t\t\t!matchesEntirely(nationalNumber, metadata.nationalNumberPattern())\r\n\t\t\t\t&&\r\n\t\t\t\tmatchesEntirely(possibleShorterNationalNumber, metadata.nationalNumberPattern())\r\n\t\t\t)\r\n\t\t\t||\r\n\t\t\tcheckNumberLength(nationalNumber, metadata) === 'TOO_LONG'\r\n\t\t) {\r\n\t\t\treturn {\r\n\t\t\t\tcountryCallingCode,\r\n\t\t\t\tnumber: possibleShorterNumber\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn { number }\r\n}\r\n"],"file":"parse_.js"}