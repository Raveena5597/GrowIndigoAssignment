{"version":3,"sources":["../source/extension.js"],"names":["VALID_DIGITS","RFC3966_EXTN_PREFIX","getExtensionDigitsPattern","maxLength","createExtensionPattern","purpose","extLimitAfterExplicitLabel","extLimitAfterLikelyLabel","extLimitAfterAmbiguousChar","extLimitWhenNotSure","possibleSeparatorsBetweenNumberAndExtLabel","possibleCharsAfterExtLabel","optionalExtnSuffix","explicitExtLabels","ambiguousExtLabels","ambiguousSeparator","possibleSeparatorsNumberExtLabelNoComma","autoDiallingAndExtLabelsFound","rfcExtn","explicitExtn","ambiguousExtn","americanStyleExtnWithSuffix","autoDiallingExtn","onlyCommasExtn","EXTN_PATTERNS_FOR_PARSING","EXTN_PATTERNS_FOR_MATCHING","EXTN_PATTERN","RegExp","extractExtension","number","start","search","numberWithoutExtension","slice","matches","match","i","length","ext"],"mappings":"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","sourcesContent":["import { VALID_DIGITS } from './constants'\r\n\r\n// The RFC 3966 format for extensions.\r\nconst RFC3966_EXTN_PREFIX = ';ext='\r\n\r\n/**\r\n * Helper method for constructing regular expressions for parsing. Creates\r\n * an expression that captures up to max_length digits.\r\n * @return {string} RegEx pattern to capture extension digits.\r\n */\r\nconst getExtensionDigitsPattern = (maxLength) => `([${VALID_DIGITS}]{1,${maxLength}})`\r\n\r\n/**\r\n * Helper initialiser method to create the regular-expression pattern to match\r\n * extensions.\r\n * Copy-pasted from Google's `libphonenumber`:\r\n * https://github.com/google/libphonenumber/blob/55b2646ec9393f4d3d6661b9c82ef9e258e8b829/javascript/i18n/phonenumbers/phonenumberutil.js#L759-L766\r\n * @return {string} RegEx pattern to capture extensions.\r\n */\r\nexport function createExtensionPattern(purpose) {\r\n\t// We cap the maximum length of an extension based on the ambiguity of the way\r\n\t// the extension is prefixed. As per ITU, the officially allowed length for\r\n\t// extensions is actually 40, but we don't support this since we haven't seen real\r\n\t// examples and this introduces many false interpretations as the extension labels\r\n\t// are not standardized.\r\n\t/** @type {string} */\r\n\tvar extLimitAfterExplicitLabel = '20';\r\n\t/** @type {string} */\r\n\tvar extLimitAfterLikelyLabel = '15';\r\n\t/** @type {string} */\r\n\tvar extLimitAfterAmbiguousChar = '9';\r\n\t/** @type {string} */\r\n\tvar extLimitWhenNotSure = '6';\r\n\r\n\t/** @type {string} */\r\n\tvar possibleSeparatorsBetweenNumberAndExtLabel = \"[ \\u00A0\\\\t,]*\";\r\n\t// Optional full stop (.) or colon, followed by zero or more spaces/tabs/commas.\r\n\t/** @type {string} */\r\n\tvar possibleCharsAfterExtLabel = \"[:\\\\.\\uFF0E]?[ \\u00A0\\\\t,-]*\";\r\n\t/** @type {string} */\r\n\tvar optionalExtnSuffix = \"#?\";\r\n\r\n\t// Here the extension is called out in more explicit way, i.e mentioning it obvious\r\n\t// patterns like \"ext.\".\r\n\t/** @type {string} */\r\n\tvar explicitExtLabels =\r\n\t  \"(?:e?xt(?:ensi(?:o\\u0301?|\\u00F3))?n?|\\uFF45?\\uFF58\\uFF54\\uFF4E?|\\u0434\\u043E\\u0431|anexo)\";\r\n\t// One-character symbols that can be used to indicate an extension, and less\r\n\t// commonly used or more ambiguous extension labels.\r\n\t/** @type {string} */\r\n\tvar ambiguousExtLabels = \"(?:[x\\uFF58#\\uFF03~\\uFF5E]|int|\\uFF49\\uFF4E\\uFF54)\";\r\n\t// When extension is not separated clearly.\r\n\t/** @type {string} */\r\n\tvar ambiguousSeparator = \"[- ]+\";\r\n\t// This is the same as possibleSeparatorsBetweenNumberAndExtLabel, but not matching\r\n\t// comma as extension label may have it.\r\n\t/** @type {string} */\r\n\tvar possibleSeparatorsNumberExtLabelNoComma = \"[ \\u00A0\\\\t]*\";\r\n\t// \",,\" is commonly used for auto dialling the extension when connected. First\r\n\t// comma is matched through possibleSeparatorsBetweenNumberAndExtLabel, so we do\r\n\t// not repeat it here. Semi-colon works in Iphone and Android also to pop up a\r\n\t// button with the extension number following.\r\n\t/** @type {string} */\r\n\tvar autoDiallingAndExtLabelsFound = \"(?:,{2}|;)\";\r\n\r\n\t/** @type {string} */\r\n\tvar rfcExtn = RFC3966_EXTN_PREFIX\r\n\t     + getExtensionDigitsPattern(extLimitAfterExplicitLabel);\r\n\t/** @type {string} */\r\n\tvar explicitExtn = possibleSeparatorsBetweenNumberAndExtLabel + explicitExtLabels\r\n\t     + possibleCharsAfterExtLabel\r\n\t     + getExtensionDigitsPattern(extLimitAfterExplicitLabel)\r\n\t     + optionalExtnSuffix;\r\n\t/** @type {string} */\r\n\tvar ambiguousExtn = possibleSeparatorsBetweenNumberAndExtLabel + ambiguousExtLabels\r\n\t     + possibleCharsAfterExtLabel\r\n\t+ getExtensionDigitsPattern(extLimitAfterAmbiguousChar)\r\n\t+ optionalExtnSuffix;\r\n\t/** @type {string} */\r\n\tvar americanStyleExtnWithSuffix = ambiguousSeparator\r\n\t+ getExtensionDigitsPattern(extLimitWhenNotSure) + \"#\";\r\n\r\n\t/** @type {string} */\r\n\tvar autoDiallingExtn = possibleSeparatorsNumberExtLabelNoComma\r\n\t     + autoDiallingAndExtLabelsFound + possibleCharsAfterExtLabel\r\n\t     + getExtensionDigitsPattern(extLimitAfterLikelyLabel)\r\n\t+ optionalExtnSuffix;\r\n\t/** @type {string} */\r\n\tvar onlyCommasExtn = possibleSeparatorsNumberExtLabelNoComma\r\n\t    + \"(?:,)+\" + possibleCharsAfterExtLabel\r\n\t    + getExtensionDigitsPattern(extLimitAfterAmbiguousChar)\r\n\t    + optionalExtnSuffix;\r\n\r\n\t// The first regular expression covers RFC 3966 format, where the extension is added\r\n\t// using \";ext=\". The second more generic where extension is mentioned with explicit\r\n\t// labels like \"ext:\". In both the above cases we allow more numbers in extension than\r\n\t// any other extension labels. The third one captures when single character extension\r\n\t// labels or less commonly used labels are used. In such cases we capture fewer\r\n\t// extension digits in order to reduce the chance of falsely interpreting two\r\n\t// numbers beside each other as a number + extension. The fourth one covers the\r\n\t// special case of American numbers where the extension is written with a hash\r\n\t// at the end, such as \"- 503#\". The fifth one is exclusively for extension\r\n\t// autodialling formats which are used when dialling and in this case we accept longer\r\n\t// extensions. The last one is more liberal on the number of commas that acts as\r\n\t// extension labels, so we have a strict cap on the number of digits in such extensions.\r\n\treturn rfcExtn + \"|\"\r\n\t       + explicitExtn + \"|\"\r\n\t       + ambiguousExtn + \"|\"\r\n\t       + americanStyleExtnWithSuffix + \"|\"\r\n\t       + autoDiallingExtn + \"|\"\r\n\t       + onlyCommasExtn;\r\n}\r\n\r\n/**\r\n * Regexp of all possible ways to write extensions, for use when parsing. This\r\n * will be run as a case-insensitive regexp match. Wide character versions are\r\n * also provided after each ASCII version. There are three regular expressions\r\n * here. The first covers RFC 3966 format, where the extension is added using\r\n * ';ext='. The second more generic one starts with optional white space and\r\n * ends with an optional full stop (.), followed by zero or more spaces/tabs\r\n * /commas and then the numbers themselves. The other one covers the special\r\n * case of American numbers where the extension is written with a hash at the\r\n * end, such as '- 503#'. Note that the only capturing groups should be around\r\n * the digits that you want to capture as part of the extension, or else parsing\r\n * will fail! We allow two options for representing the accented o - the\r\n * character itself, and one in the unicode decomposed form with the combining\r\n * acute accent.\r\n */\r\nexport const EXTN_PATTERNS_FOR_PARSING = createExtensionPattern('parsing')\r\n\r\nexport const EXTN_PATTERNS_FOR_MATCHING = createExtensionPattern('matching')\r\n\r\n// Regexp of all known extension prefixes used by different regions followed by\r\n// 1 or more valid digits, for use when parsing.\r\nconst EXTN_PATTERN = new RegExp('(?:' + createExtensionPattern() + ')$', 'i')\r\n\r\n// Strips any extension (as in, the part of the number dialled after the call is\r\n// connected, usually indicated with extn, ext, x or similar) from the end of\r\n// the number, and returns it.\r\nexport function extractExtension(number) {\r\n\tconst start = number.search(EXTN_PATTERN)\r\n\tif (start < 0) {\r\n\t\treturn {}\r\n\t}\r\n\t// If we find a potential extension, and the number preceding this is a viable\r\n\t// number, we assume it is an extension.\r\n\tconst numberWithoutExtension = number.slice(0, start)\r\n\tconst matches = number.match(EXTN_PATTERN)\r\n\tlet i = 1\r\n\twhile (i < matches.length) {\r\n\t\tif (matches[i]) {\r\n\t\t\treturn {\r\n\t\t\t\tnumber: numberWithoutExtension,\r\n\t\t\t\text: matches[i]\r\n\t\t\t}\r\n\t\t}\r\n\t\ti++\r\n\t}\r\n}"],"file":"extension.js"}